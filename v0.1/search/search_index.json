{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documention for <code>mibiremo</code> python package","text":"<p>Microbiome Bioremediation Reaction Module, a Python interface to PhreeqcRM library. Developed as part of the MiBiRem toolbox for Bioremediation.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibiremo from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibiremo.git\ncd mibiremo\npython -m pip mibiremo .\n</code></pre>"},{"location":"development/","title":"<code>mibiremo</code> developer documentation","text":""},{"location":"development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibiremo as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibiremo</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibiremo/</code>) where the docs site can be viewed.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"development/#making-a-release","title":"Making a release","text":"<p>This section describes how to make a release in 3 parts:</p> <ol> <li>preparation</li> <li>making a release on PyPI</li> <li>making a release on GitHub</li> </ol>"},{"location":"development/#13-preparation","title":"(1/3) Preparation","text":"<ol> <li>Verify that the information in CITATION.cff is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> </ol>"},{"location":"development/#23-pypi","title":"(2/3) PyPI","text":"<p>In a new terminal:</p> <pre><code># OPTIONAL: prepare a new directory with fresh git clone to ensure the release\n# has the state of origin/main branch\ncd $(mktemp -d mibiremo.XXXXXX)\ngit clone git@github.com:MiBiPreT/mibiremo .\n\n# make sure to have a recent version of pip and the publishing dependencies\npython -m pip install --upgrade pip\npython -m pip install .[publishing]\n\n# create the source distribution and the wheel\npython -m build\n\n# upload to test pypi instance (requires credentials)\npython -m twine upload --repository testpypi dist/*\n</code></pre> <p>Visit https://test.pypi.org/</p> <p>and verify that your package was uploaded successfully. Keep the terminal open, we\u2019ll need it later.</p> <p>In a new terminal, without an activated virtual environment or an env directory:</p> <pre><code>cd $(mktemp -d mibiremo-test.XXXXXX)\n\n# prepare a clean virtual environment and activate it\npython -m venv env\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip\n\n# install from test pypi instance:\npython -m pip -v install --no-cache-dir \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple mibiremo\n</code></pre> <p>Check that the package works as it should when installed from pypitest.</p> <p>Then upload to pypi.org with:</p> <pre><code># Back to the first terminal,\n# FINAL STEP: upload to PyPI (requires credentials)\npython -m twine upload dist/*\n</code></pre>"},{"location":"development/#33-github","title":"(3/3) GitHub","text":"<p>Don\u2019t forget to also make a release on GitHub. If your repository uses the GitHub-Zenodo integration this will also trigger Zenodo into making a snapshot of your repository and sticking a DOI on it.</p>"},{"location":"examples/","title":"MiBiReMo - Examples","text":"<p>Currently, three examples are available.  To run the examples, navigate to the <code>examples</code> directory and run the desired example script: <pre><code>cd path/to/project_folder\nsource mibiremo/bin/activate\ncd path/to/mibiremo_source/examples\npython ex1-titration.py\n</code></pre></p>"},{"location":"examples/#example-1-titration","title":"Example 1 - Titration","text":"<p>The first example <code>ex1-titration.py</code> demonstrates the use of the package to simulate a simple titration in a batch, where a solution is equilibrated with a mineral phase (calcite) and the pH is adjusted by adding HCl.</p>"},{"location":"examples/#example-2-benzene-and-ethylbenzene-kinetic-dissolution","title":"Example 2 - Benzene and Ethylbenzene kinetic dissolution","text":"<p>The second example <code>ex2-BTEX_dissolution.py</code> demonstrates the use of the package to simulate the kinetic dissolution of benzene and ethylbenzene in a batch reactor.</p>"},{"location":"examples/#example-3-reactive-transport-btex-dissolution-and-transport","title":"Example 3 - Reactive transport - BTEX dissolution and transport","text":"<p>The third example <code>ex3-BTEX_dissolution_transport_coupling.py</code> demonstrates the use of the package to simulate the reactive transport of benzene and ethylbenzene in a 1D domain. The problem is described in the following scheme:</p> <p></p> <p>The model consists of a 1D domain with a length of 50 m. The domain is initially filled with clean groundwater with a spot of benzene and ethylbenzene pure phases present at the left side of the domain extending for 0.5 m. We assumed that the contaminant pure phase in the source zone is immobile (it only dissolves). The groundwater flows from left to right with a velocity of 1 m/d, and dissolved benzene and ethylbenzene are transported towards the right end of the domain. The dissolution process is modelled both kinetically and equilibrium-based.  The model is run for 100 days, and the concentration of benzene and ethylbenzene is monitored at the right side of the domain.</p> <p>Three simulation runs are performed: 1. Equilibrium dissolution of benzene and ethylbenzene simulated with PHREEQC (standalone). 2. Equilibrium dissolution of benzene and ethylbenzene simulated by MiBiReMo (1D transport solver coupled with PhreeqcRM). 3. Kinetic dissolution of benzene and ethylbenzene simulated by MiBiReMo.</p> <p>The transport equition (advection and dispersion) in MiBiReMo is solved using a Semi-Lagrangian scheme with operator splitting, where the advection is solved using the method of characteristics with cubic spline interpolation, and the dispersion is solved using the Saul\u2019yev finite differences technique. </p> <p>Simulation results are shown in the following figure:</p> <p></p> <p>The results obtaines show a pattern similar to the experimental results obtained by Geller and Hunt (1993) [1]. In their experiment they injected an equimolar mixture of benzene and toluene in the center of a column which was subsequently eluted with water. The results show that benzene is eluted first, followed by toluene because of the different solubilities. The following figure shows the experimental results obtained by Geller and Hunt (1993):</p> <p></p>"},{"location":"examples/#references","title":"References","text":"<p>[1] Geller, J. T., and J. R. Hunt (1993), Mass transfer from nonaqueous phase organic liquids in water-saturated porous media, Water Resour. Res., 29(4), 833\u2013845, doi:10.1029/92WR02581. </p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#general","title":"General","text":"<p>MiBiReMo (Microbiome Bioremediation Reaction Module) is a Python interface to the PhreeqcRM library. The package is designed to be coupled with transport models to simulate reactive transport in porous media, with applications in environmental and geochemical engineering.</p>"},{"location":"introduction/#mibirem","title":"MIBIREM","text":"<p>MIBIREM - Innovative technological toolbox for bioremediation is a EU funded consortium project by 12 international partners all over Europe working together to develop an Innovative technological toolbox for bioremediation. The project will develop molecular methods for the monitoring, isolation, cultivation and subsequent deposition of whole microbiomes. The toolbox will also include the methodology for the improvement of specific microbiome functions, including evolution and enrichment. The performance of selected microbiomes will be tested under real field conditions. The <code>mibipret</code> package is part of this toolbox.</p>"},{"location":"reference/","title":"<code>mibiremo</code> API reference","text":""},{"location":"reference/#mibiremo.irmresult","title":"<code>irmresult</code>","text":""},{"location":"reference/#mibiremo.irmresult.IRM_RESULT","title":"<code>IRM_RESULT(code)</code>","text":"<p>Map error codes (integer) to error messages Returns the error as a tuple (ERR_CODE, DESCRIPTION) See: IrmResult.h File Reference.</p> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def IRM_RESULT(code):\n    \"\"\"Map error codes (integer) to error messages\n    Returns the error as a tuple (ERR_CODE, DESCRIPTION)\n    See: IrmResult.h File Reference.\n    \"\"\"\n    map = {\n        0: (\"IRM_OK\", \"Success\"),\n        -1: (\"IRM_OUTOFMEMORY\", \"Failure, Out of memory\"),\n        -2: (\"IRM_BADVARTYPE\", \"Failure, Invalid VAR type\"),\n        -3: (\"IRM_INVALIDARG\", \"Failure, Invalid argument\"),\n        -4: (\"IRM_INVALIDROW\", \"Failure, Invalid row\"),\n        -5: (\"IRM_INVALIDCOL\", \"Failure, Invalid column\"),\n        -6: (\"IRM_BADINSTANCE\", \"Failure, Invalid rm instance id\"),\n        -7: (\"IRM_FAIL\", \"Failure, Unspecified\"),\n    }\n\n    if code in map:\n        return map[code]\n    return (\"UNSPECIFIED\", \"Invalid error code\")\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc","title":"<code>phreeqc</code>","text":""},{"location":"reference/#mibiremo.phreeqc--python-phreeqcrm-interface","title":"Python-PhreeqcRM interface.","text":"<p>PhreeqcRM documentation: https://usgs-coupled.github.io/phreeqcrm/namespacephreeqcrm.html</p> <p>Last revision: 03/07/2024</p>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM","title":"<code>PhreeqcRM</code>","text":"Source code in <code>mibiremo/phreeqc.py</code> <pre><code>class PhreeqcRM:\n    def __init__(self):\n        \"\"\"Initialize PhreeqcRM instance.\"\"\"\n        self.dllpath = None\n        self.nxyz = 1\n        self.n_threads = 1\n        self.libc = None\n        self.id = None\n\n    def create(self, dllpath=\"\", nxyz=1, n_threads=1) -&gt; None:\n        \"\"\"Create a PhreeqcRM instance\n        Args:\n            dllpath: Path to the PhreeqcRM library. If left empty, the provided libraries are used.\n            nxyz: Number of grid cells. Default: 1.\n            n_threads: Number of threads. Default: 1.\n        \"\"\"\n        if dllpath == \"\":\n            # If no path is provided, use the default path, based on operating system\n            if os.name == \"nt\":\n                dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.dll\")\n            elif os.name == \"posix\":\n                dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.so\")\n            else:\n                msg = \"Operating system not supported\"\n                raise Exception(msg)\n        self.dllpath = dllpath\n\n        if n_threads == -1:\n            n_threads = os.cpu_count()\n\n        self.n_threads = n_threads\n        self.nxyz = nxyz\n        self.libc = ctypes.CDLL(dllpath)\n        self.id = self.libc.RM_Create(nxyz, n_threads)\n\n    def pdSelectedOutput(self):\n        \"\"\"Returns a Pandas data frame for Selected Output.\"\"\"\n        # Get selected ouput headings\n        ncolsel = self.RM_GetSelectedOutputColumnCount()\n        selout_h = np.zeros(ncolsel, dtype=\"U100\")\n        for i in range(ncolsel):\n            self.RM_GetSelectedOutputHeading(i, selout_h, 100)\n        so = np.zeros(ncolsel * self.nxyz).reshape(self.nxyz, ncolsel)\n        self.RM_GetSelectedOutput(so)\n        return pd.DataFrame(so.reshape(ncolsel, self.nxyz).T, columns=selout_h)\n\n    ### PhreeqcRM functions\n\n    def RM_Abort(self, result, err_str):\n        return IRM_RESULT(self.libc.RM_Abort(self.id, result, err_str))\n\n    def RM_CloseFiles(self):\n        return self.libc.RM_CloseFiles(self)\n\n    def RM_Concentrations2Utility(self, c, n, tc, p_atm):\n        return self.libc.RM_Concentrations2Utility(self.id, c, n, tc, p_atm)\n\n    def RM_CreateMapping(self, grid2chem):\n        return self.libc.RM_CreateMapping(self.id, grid2chem.ctypes)\n\n    def RM_DecodeError(self, e):\n        return self.libc.RM_DecodeError(self.id, e)\n\n    def RM_Destroy(self):\n        return self.libc.RM_Destroy(self.id)\n\n    def RM_DumpModule(self, dump_on, append):\n        return self.libc.RM_DumpModule(self.id, dump_on, append)\n\n    def RM_ErrorMessage(self, errstr):\n        return self.libc.RM_ErrorMessage(self.id, errstr)\n\n    def RM_FindComponents(self):\n        return self.libc.RM_FindComponents(self.id)\n\n    def RM_GetBackwardMapping(self, n, list, size):\n        return self.libc.RM_GetBackwardMapping(self.id, n, list, size)\n\n    def RM_GetChemistryCellCount(self):\n        return self.libc.RM_GetChemistryCellCount(self.id)\n\n    def RM_GetComponent(self, num, chem_name, length):\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetComponent(self.id, num, String, length)\n        chem_name[num] = String.value.decode()\n        return status\n\n    def RM_GetConcentrations(self, c):\n        return self.libc.RM_GetConcentrations(self.id, c.ctypes)\n\n    def RM_GetDensity(self, density):\n        return self.libc.RM_GetDensity(self.id, density.ctypes)\n\n    def RM_GetEndCell(self, ec):\n        return self.libc.RM_GetEndCell(self.id, ec)\n\n    def RM_GetEquilibriumPhaseCount(self):\n        return self.libc.RM_GetEquilibriumPhaseCount(self.id)\n\n    def RM_GetEquilibriumPhaseName(self, num, name, l1):\n        return self.libc.RM_GetEquilibriumPhaseName(self.id, num, name, l1)\n\n    def RM_GetErrorString(self, errstr, length):\n        return self.libc.RM_GetErrorString(self.id, errstr, length)\n\n    def RM_GetErrorStringLength(self):\n        return self.libc.RM_GetErrorStringLength(self.id)\n\n    def RM_GetExchangeName(self, num, name, l1):\n        return self.libc.RM_GetExchangeName(self.id, num, name, l1)\n\n    def RM_GetExchangeSpeciesCount(self):\n        return self.libc.RM_GetExchangeSpeciesCount(self.id)\n\n    def RM_GetExchangeSpeciesName(self, num, name, l1):\n        return self.libc.RM_GetExchangeSpeciesName(self.id, num, name, l1)\n\n    def RM_GetFilePrefix(self, prefix, length):\n        return self.libc.RM_GetFilePrefix(self.id, prefix.encode(), length)\n\n    def RM_GetGasComponentsCount(self):\n        return self.libc.RM_GetGasComponentsCount(self.id)\n\n    def RM_GetGasComponentsName(self, nun, name, l1):\n        return self.libc.RM_GetGasComponentsName(self.id, nun, name, l1)\n\n    def RM_GetGfw(self, gfw):\n        return self.libc.RM_GetGfw(self.id, gfw.ctypes)\n\n    def RM_GetGridCellCount(self):\n        return self.libc.RM_GetGridCellCount(self.id)\n\n    def RM_GetIPhreeqcId(self, i):\n        return self.libc.RM_GetIPhreeqcId(self.id, i)\n\n    def RM_GetKineticReactionsCount(self):\n        return self.libc.RM_GetKineticReactionsCount(self.id)\n\n    def RM_GetKineticReactionsName(self, num, name, l1):\n        return self.libc.RM_GetKineticReactionsName(self.id, num, name, l1)\n\n    def RM_GetMpiMyself(self):\n        return self.libc.RM_GetMpiMyself(self.id)\n\n    def RM_GetMpiTasks(self):\n        return self.libc.RM_GetMpiTasks(self.id)\n\n    def RM_GetNthSelectedOutputUserNumber(self, n):\n        return self.libc.RM_GetNthSelectedOutputUserNumber(self.id, n)\n\n    def RM_GetSaturation(self, sat_calc):\n        return self.libc.RM_GetSaturation(self.id, sat_calc)\n\n    def RM_GetSelectedOutput(self, so):\n        return self.libc.RM_GetSelectedOutput(self.id, so.ctypes)\n\n    def RM_GetNthSelectedOutputColumnCount(self):\n        return self.libc.RM_GetNthSelectedOutputColumnCount(self.id)\n\n    def RM_GetSelectedOutputCount(self):\n        return self.libc.RM_GetSelectedOutputCount(self.id)\n\n    def RM_GetSelectedOutputHeading(self, col, headings, length):\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetSelectedOutputHeading(self.id, col, String, length)\n        headings[col] = String.value.decode()\n        return status\n\n    def RM_GetSelectedOutputColumnCount(self):\n        return self.libc.RM_GetSelectedOutputColumnCount(self.id)\n\n    def RM_GetSelectedOutputRowCount(self):\n        return self.libc.RM_GetSelectedOutputRowCount(self.id)\n\n    def RM_GetSICount(self):\n        return self.libc.RM_GetSICount(self.id)\n\n    def RM_GetSIName(self, num, name, l1):\n        return self.libc.RM_GetSIName(self.id, num, name, l1)\n\n    def RM_GetSolidSolutionComponentsCount(self):\n        return self.libc.RM_GetSolidSolutionComponentsCount(self.id)\n\n    def RM_GetSolidSolutionComponentsName(self, num, name, l1):\n        return self.libc.RM_GetSolidSolutionComponentsName(self.id, num, name, l1)\n\n    def RM_GetSolidSolutionName(self, num, name, l1):\n        return self.libc.RM_GetSolidSolutionName(self.id, num, name, l1)\n\n    def RM_GetSolutionVolume(self, vol):\n        return self.libc.RM_GetSolutionVolume(self.id, vol.ctypes)\n\n    def RM_GetSpeciesConcentrations(self, species_conc):\n        return self.libc.RM_GetSpeciesConcentrations(self.id, species_conc.ctypes)\n\n    def RM_GetSpeciesCount(self):\n        return self.libc.RM_GetSpeciesCount(self.id)\n\n    def RM_GetSpeciesD25(self, diffc):\n        return self.libc.RM_GetSpeciesD25(self.id, diffc.ctypes)\n\n    def RM_GetSpeciesLog10Gammas(self, species_log10gammas):\n        return self.libc.RM_GetSpeciesLog10Gammas(self.id, species_log10gammas)\n\n    def RM_GetSpeciesName(self, num, chem_name, length):\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetSpeciesName(self.id, num, String, length)\n        chem_name[num] = String.value.decode()\n        return status\n\n    def RM_GetSpeciesSaveOn(self):\n        return self.libc.RM_GetSpeciesSaveOn(self.id)\n\n    def RM_GetSpeciesZ(self, Z):\n        return self.libc.RM_GetSpeciesZ(self.id, Z)\n\n    def RM_GetStartCell(self, sc):\n        return self.libc.RM_GetStartCell(self.id, sc)\n\n    def RM_GetSurfaceName(self, num, name, l1):\n        return self.libc.RM_GetSurfaceName(self.id, num, name, l1)\n\n    def RM_GetSurfaceType(self, num, name, l1):\n        return self.libc.RM_GetSurfaceType(self.id, num, name, l1)\n\n    def RM_GetThreadCount(self):\n        return self.libc.RM_GetThreadCount(self.id)\n\n    def RM_GetTime(self):\n        self.libc.RM_GetTime.restype = ctypes.c_double\n        return self.libc.RM_GetTime(self.id)\n\n    def RM_GetTimeConversion(self):\n        self.libc.RM_GetTimeConversion.restype = ctypes.c_double\n        return self.libc.RM_GetTimeConversion(self.id)\n\n    def RM_GetTimeStep(self):\n        self.libc.RM_GetTimeStep.restype = ctypes.c_double\n        return self.libc.RM_GetTimeStep(self.id)\n\n    def RM_InitialPhreeqc2Module(self, ic1, ic2, f1):\n        return self.libc.RM_InitialPhreeqc2Module(self.id, ic1.ctypes, ic2.ctypes, f1.ctypes)\n\n    def RM_InitialPhreeqc2Concentrations(self, c, n_boundary, boundary_solution1, boundary_solution2, fraction1):\n        return self.libc.RM_InitialPhreeqc2Concentrations(\n            self.id, c.ctypes, n_boundary, boundary_solution1.ctypes, boundary_solution2.ctypes, fraction1.ctypes\n        )\n\n    def RM_InitialPhreeqc2SpeciesConcentrations(\n        self, species_c, n_boundary, boundary_solution1, boundary_solution2, fraction1\n    ):\n        return self.libc.RM_InitialPhreeqc2SpeciesConcentrations(\n            self.id,\n            species_c.ctypes,\n            n_boundary.ctypes,\n            boundary_solution1.ctypes,\n            boundary_solution2.ctypes,\n            fraction1.ctypes,\n        )\n\n    def RM_InitialPhreeqcCell2Module(self, n, module_numbers, dim_module_numbers):\n        return self.libc.RM_InitialPhreeqcCell2Module(self.id, n, module_numbers, dim_module_numbers)\n\n    def RM_LoadDatabase(self, db_name):\n        return self.libc.RM_LoadDatabase(self.id, db_name.encode())\n\n    def RM_LogMessage(self, str):\n        return self.libc.RM_LogMessage(self.id, str.encode())\n\n    def RM_MpiWorker(self):\n        return self.libc.RM_MpiWorker(self.id)\n\n    def RM_MpiWorkerBreak(self):\n        return self.libc.RM_MpiWorkerBreak(self.id)\n\n    def RM_OpenFiles(self):\n        return self.libc.RM_OpenFiles(self.id)\n\n    def RM_OutputMessage(self, str):\n        return self.libc.RM_OutputMessage(self.id, str.encode())\n\n    def RM_RunCells(self):\n        return self.libc.RM_RunCells(self.id)\n\n    def RM_RunFile(self, workers, initial_phreeqc, utility, chem_name):\n        return self.libc.RM_RunFile(self.id, workers, initial_phreeqc, utility, chem_name.encode())\n\n    def RM_RunString(self, workers, initial_phreeqc, utility, input_string):\n        return self.libc.RM_RunString(self.id, workers, initial_phreeqc, utility, input_string.encode())\n\n    def RM_ScreenMessage(self, str):\n        return self.libc.RM_ScreenMessage(self.id, str.encode())\n\n    def RM_SetComponentH2O(self, tf):\n        return self.libc.RM_SetComponentH2O(self.id, tf)\n\n    def RM_SetConcentrations(self, c):\n        return self.libc.RM_SetConcentrations(self.id, c.ctypes)\n\n    def RM_SetCurrentSelectedOutputUserNumber(self, n_user):\n        return self.libc.RM_SetCurrentSelectedOutputUserNumber(self.id, n_user)\n\n    def RM_SetDensity(self, density):\n        return self.libc.RM_SetDensity(self.id, density.ctypes)\n\n    def RM_SetDumpFileName(self, dump_name):\n        return self.libc.RM_SetDumpFileName(self.id, dump_name)\n\n    def RM_SetErrorHandlerMode(self, mode):\n        return self.libc.RM_SetErrorHandlerMode(self.id, mode)\n\n    def RM_SetFilePrefix(self, prefix):\n        return self.libc.RM_SetFilePrefix(self.id, prefix.encode())\n\n    def RM_SetMpiWorkerCallbackCookie(self, cookie):\n        return self.libc.RM_SetMpiWorkerCallbackCookie(self.id, cookie)\n\n    def RM_SetPartitionUZSolids(self, tf):\n        return self.libc.RM_SetPartitionUZSolids(self.id, tf)\n\n    def RM_SetPorosity(self, por):\n        return self.libc.RM_SetPorosity(self.id, por.ctypes)\n\n    def RM_SetPressure(self, p):\n        return self.libc.RM_SetPressure(self.id, p.ctypes)\n\n    def RM_SetPrintChemistryMask(self, cell_mask):\n        return self.libc.RM_SetPrintChemistryMask(self.id, cell_mask.ctypes)\n\n    def RM_SetPrintChemistryOn(self, workers, initial_phreeqc, utility):\n        return self.libc.RM_SetPrintChemistryOn(self.id, workers, initial_phreeqc, utility)\n\n    def RM_SetRebalanceByCell(self, method):\n        return self.libc.RM_SetRebalanceByCell(self.id, method)\n\n    def RM_SetRebalanceFraction(self, f):\n        return self.libc.RM_SetRebalanceFraction(self.id, ctypes.c_double(f))\n\n    def RM_SetRepresentativeVolume(self, rv):\n        return self.libc.RM_SetRepresentativeVolume(self.id, rv.ctypes)\n\n    def RM_SetSaturation(self, sat):\n        return self.libc.RM_SetSaturation(self.id, sat.ctypes)\n\n    def RM_SetScreenOn(self, tf):\n        return self.libc.RM_SetScreenOn(self.id, tf)\n\n    def RM_SetSelectedOutputOn(self, selected_output):\n        return self.libc.RM_SetSelectedOutputOn(self.id, selected_output)\n\n    def RM_SetSpeciesSaveOn(self, save_on):\n        return self.libc.RM_SetSpeciesSaveOn(self.id, save_on)\n\n    def RM_SetTemperature(self, t):\n        return self.libc.RM_SetTemperature(self.id, t.ctypes)\n\n    def RM_SetTime(self, time):\n        return self.libc.RM_SetTime(self.id, ctypes.c_double(time))\n\n    def RM_SetTimeConversion(self, conv_factor):\n        return self.libc.RM_SetTimeConversion(self.id, ctypes.c_double(conv_factor))\n\n    def RM_SetTimeStep(self, time_step):\n        return self.libc.RM_SetTimeStep(self.id, ctypes.c_double(time_step))\n\n    def RM_SetUnitsExchange(self, option):\n        return self.libc.RM_SetUnitsExchange(self.id, option)\n\n    def RM_SetUnitsGasPhase(self, option) -&gt; None:\n        self.libc.RM_SetUnitsGasPhase(self.id, option)\n\n    def RM_SetUnitsKinetics(self, option) -&gt; None:\n        self.libc.RM_SetUnitsKinetics(self.id, option)\n\n    def RM_SetUnitsPPassemblage(self, option):\n        return self.libc.RM_SetUnitsPPassemblage(self.id, option)\n\n    def RM_SetUnitsSolution(self, option):\n        return self.libc.RM_SetUnitsSolution(self.id, option)\n\n    def RM_SetUnitsSSassemblage(self, option):\n        return self.libc.RM_SetUnitsSSassemblage(self.id, option)\n\n    def RM_SetUnitsSurface(self, option):\n        return self.libc.RM_SetUnitsSurface(self.id, option)\n\n    def RM_SpeciesConcentrations2Module(self, species_conc):\n        return self.libc.RM_SpeciesConcentrations2Module(self.id, species_conc.ctypes)\n\n    def RM_UseSolutionDensityVolume(self, tf):\n        return self.libc.RM_UseSolutionDensityVolume(self.id, tf)\n\n    def RM_WarningMessage(self, warn_str):\n        return self.libc.RM_WarningMessage(self.id, warn_str)\n\n    def RM_GetComponentCount(self):\n        return self.libc.RM_GetComponentCount(self.id)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.__init__","title":"<code>__init__()</code>","text":"<p>Initialize PhreeqcRM instance.</p> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize PhreeqcRM instance.\"\"\"\n    self.dllpath = None\n    self.nxyz = 1\n    self.n_threads = 1\n    self.libc = None\n    self.id = None\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.create","title":"<code>create(dllpath='', nxyz=1, n_threads=1)</code>","text":"<p>Create a PhreeqcRM instance Args:     dllpath: Path to the PhreeqcRM library. If left empty, the provided libraries are used.     nxyz: Number of grid cells. Default: 1.     n_threads: Number of threads. Default: 1.</p> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def create(self, dllpath=\"\", nxyz=1, n_threads=1) -&gt; None:\n    \"\"\"Create a PhreeqcRM instance\n    Args:\n        dllpath: Path to the PhreeqcRM library. If left empty, the provided libraries are used.\n        nxyz: Number of grid cells. Default: 1.\n        n_threads: Number of threads. Default: 1.\n    \"\"\"\n    if dllpath == \"\":\n        # If no path is provided, use the default path, based on operating system\n        if os.name == \"nt\":\n            dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.dll\")\n        elif os.name == \"posix\":\n            dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.so\")\n        else:\n            msg = \"Operating system not supported\"\n            raise Exception(msg)\n    self.dllpath = dllpath\n\n    if n_threads == -1:\n        n_threads = os.cpu_count()\n\n    self.n_threads = n_threads\n    self.nxyz = nxyz\n    self.libc = ctypes.CDLL(dllpath)\n    self.id = self.libc.RM_Create(nxyz, n_threads)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.pdSelectedOutput","title":"<code>pdSelectedOutput()</code>","text":"<p>Returns a Pandas data frame for Selected Output.</p> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def pdSelectedOutput(self):\n    \"\"\"Returns a Pandas data frame for Selected Output.\"\"\"\n    # Get selected ouput headings\n    ncolsel = self.RM_GetSelectedOutputColumnCount()\n    selout_h = np.zeros(ncolsel, dtype=\"U100\")\n    for i in range(ncolsel):\n        self.RM_GetSelectedOutputHeading(i, selout_h, 100)\n    so = np.zeros(ncolsel * self.nxyz).reshape(self.nxyz, ncolsel)\n    self.RM_GetSelectedOutput(so)\n    return pd.DataFrame(so.reshape(ncolsel, self.nxyz).T, columns=selout_h)\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver","title":"<code>semilagsolver</code>","text":"<p>Semi-Lagrangian solver for 1D advection-diffusion equation on a uniform grid.</p> <p>Advection and diffusion are solved separately (operator splitting) in two steps: 1) Advection solved with method of characteristics (MOC) with cubic spline interpolation 2) Diffusion solved with Saul\u2019yev method</p> <p>Author: Matteo Masi Last revision: 08/07/2024</p>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver","title":"<code>SemiLagSolver</code>","text":"<p>Implements a semi-Lagrangian integration scheme with Dirichlet-type boundary condition at the inlet of the domain (left boundary x = 0) and Neumann-type boundary condition at the outlet (right boundary).</p> Usage <p>obj = SemiLagSolver(x, C, v, D, dt)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Spatial coordinates (must be equally spaced)</p> required <code>C</code> <code>ndarray</code> <p>Initial concentration</p> required <code>v</code> <code>float</code> <p>Velocity</p> required <code>D</code> <code>float</code> <p>Diffusion (dispersion) coefficient</p> required <code>dt</code> <code>float</code> <p>Time-step</p> required Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>class SemiLagSolver:\n    \"\"\"Implements a semi-Lagrangian integration scheme with Dirichlet-type boundary\n    condition at the inlet of the domain (left boundary x = 0)\n    and Neumann-type boundary condition at the outlet (right boundary).\n\n    Usage:\n        obj = SemiLagSolver(x, C, v, D, dt)\n\n    Parameters:\n        x (np.ndarray): Spatial coordinates (must be equally spaced)\n        C (np.ndarray): Initial concentration\n        v (float): Velocity\n        D (float): Diffusion (dispersion) coefficient\n        dt (float): Time-step\n\n    \"\"\"\n\n    def __init__(self, x, C_init, v, D, dt):\n        \"\"\"Initializes the SemiLagSolver object with spatial coordinates,\n        initial concentration, velocity, diffusion coefficient, and time-step.\n        \"\"\"\n        self.x = x\n        self.C = C_init\n        self.v = v\n        self.D = D\n        self.dt = dt\n        self.dx = x[1] - x[0]\n\n    def cubic_spline_advection(self, C_bound) -&gt; None:\n        \"\"\"Advection\n        Propagates the current variable using a cubic spline interpolation.\n        \"\"\"\n        cs = PchipInterpolator(self.x, self.C)\n        shift = self.v * self.dt\n        xi = self.x - shift\n        k0 = xi &lt;= 0\n        xi[k0] = 0\n        yi = cs(xi)\n        yi[k0] = C_bound\n        self.C = yi\n\n    def saulyev_solver_alt(self, C_bound) -&gt; None:\n        \"\"\"Diffusion\n        Saul'yev explicit solver (integration in alternating directions).\n        \"\"\"\n        dt = self.dt\n        theta = self.D * dt / (self.dx**2)\n\n        # Assign current C state as initial condition\n        C_init = self.C.copy()\n        CLR = self.C.copy()\n        CRL = self.C.copy()\n\n        # A) L-R direction\n        for i in range(len(CLR)):\n            if i == 0:  # left boundary\n                solA = theta * C_bound\n            else:\n                solA = theta * CLR[i - 1]\n            solB = (1 - theta) * C_init[i]\n            solC = theta * C_init[i + 1] if i &lt; len(CLR) - 1 else theta * C_init[i]\n            # L-R Solution\n            CLR[i] = (solA + solB + solC) / (1 + theta)\n\n        # B) R-L direction\n        for i in range(len(CRL) - 1, -1, -1):\n            if i == len(CRL) - 1:  # right boundary (take from LR solution)\n                solA = theta * CLR[-1]\n            else:\n                solA = theta * CRL[i + 1]\n            solB = (1 - theta) * C_init[i]\n            solC = theta * C_init[i - 1] if i &gt; 0 else theta * C_init[i]\n            # R-L Solution\n            CRL[i] = (solA + solB + solC) / (1 + theta)\n\n        # Average L-R and R-L solutions and update to final state\n        self.C = (CLR + CRL) / 2\n\n    def transport(self, C_bound):\n        \"\"\"Couple advection and diffusion.\"\"\"\n        # Advection\n        self.cubic_spline_advection(C_bound)\n\n        # Diffusion\n        self.saulyev_solver_alt(C_bound)\n\n        return self.C\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.__init__","title":"<code>__init__(x, C_init, v, D, dt)</code>","text":"<p>Initializes the SemiLagSolver object with spatial coordinates, initial concentration, velocity, diffusion coefficient, and time-step.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def __init__(self, x, C_init, v, D, dt):\n    \"\"\"Initializes the SemiLagSolver object with spatial coordinates,\n    initial concentration, velocity, diffusion coefficient, and time-step.\n    \"\"\"\n    self.x = x\n    self.C = C_init\n    self.v = v\n    self.D = D\n    self.dt = dt\n    self.dx = x[1] - x[0]\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.cubic_spline_advection","title":"<code>cubic_spline_advection(C_bound)</code>","text":"<p>Advection Propagates the current variable using a cubic spline interpolation.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def cubic_spline_advection(self, C_bound) -&gt; None:\n    \"\"\"Advection\n    Propagates the current variable using a cubic spline interpolation.\n    \"\"\"\n    cs = PchipInterpolator(self.x, self.C)\n    shift = self.v * self.dt\n    xi = self.x - shift\n    k0 = xi &lt;= 0\n    xi[k0] = 0\n    yi = cs(xi)\n    yi[k0] = C_bound\n    self.C = yi\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.saulyev_solver_alt","title":"<code>saulyev_solver_alt(C_bound)</code>","text":"<p>Diffusion Saul\u2019yev explicit solver (integration in alternating directions).</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def saulyev_solver_alt(self, C_bound) -&gt; None:\n    \"\"\"Diffusion\n    Saul'yev explicit solver (integration in alternating directions).\n    \"\"\"\n    dt = self.dt\n    theta = self.D * dt / (self.dx**2)\n\n    # Assign current C state as initial condition\n    C_init = self.C.copy()\n    CLR = self.C.copy()\n    CRL = self.C.copy()\n\n    # A) L-R direction\n    for i in range(len(CLR)):\n        if i == 0:  # left boundary\n            solA = theta * C_bound\n        else:\n            solA = theta * CLR[i - 1]\n        solB = (1 - theta) * C_init[i]\n        solC = theta * C_init[i + 1] if i &lt; len(CLR) - 1 else theta * C_init[i]\n        # L-R Solution\n        CLR[i] = (solA + solB + solC) / (1 + theta)\n\n    # B) R-L direction\n    for i in range(len(CRL) - 1, -1, -1):\n        if i == len(CRL) - 1:  # right boundary (take from LR solution)\n            solA = theta * CLR[-1]\n        else:\n            solA = theta * CRL[i + 1]\n        solB = (1 - theta) * C_init[i]\n        solC = theta * C_init[i - 1] if i &gt; 0 else theta * C_init[i]\n        # R-L Solution\n        CRL[i] = (solA + solB + solC) / (1 + theta)\n\n    # Average L-R and R-L solutions and update to final state\n    self.C = (CLR + CRL) / 2\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.transport","title":"<code>transport(C_bound)</code>","text":"<p>Couple advection and diffusion.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def transport(self, C_bound):\n    \"\"\"Couple advection and diffusion.\"\"\"\n    # Advection\n    self.cubic_spline_advection(C_bound)\n\n    # Diffusion\n    self.saulyev_solver_alt(C_bound)\n\n    return self.C\n</code></pre>"}]}