{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documention for <code>mibiremo</code> python package","text":"<p>Microbiome Bioremediation Reaction Module, a Python interface to PhreeqcRM library. Developed as part of the MiBiRem toolbox for Bioremediation.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibiremo from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibiremo.git\ncd mibiremo\npython -m pip mibiremo .\n</code></pre>"},{"location":"development/","title":"<code>mibiremo</code> developer documentation","text":""},{"location":"development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibiremo as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibiremo</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibiremo/</code>) where the docs site can be viewed.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"development/#making-a-release","title":"Making a release","text":"<p>This section describes how to make a release in 3 parts:</p> <ol> <li>preparation</li> <li>making a release on PyPI</li> <li>making a release on GitHub</li> </ol>"},{"location":"development/#13-preparation","title":"(1/3) Preparation","text":"<ol> <li>Verify that the information in CITATION.cff is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> </ol>"},{"location":"development/#23-pypi","title":"(2/3) PyPI","text":"<p>In a new terminal:</p> <pre><code># OPTIONAL: prepare a new directory with fresh git clone to ensure the release\n# has the state of origin/main branch\ncd $(mktemp -d mibiremo.XXXXXX)\ngit clone git@github.com:MiBiPreT/mibiremo .\n\n# make sure to have a recent version of pip and the publishing dependencies\npython -m pip install --upgrade pip\npython -m pip install .[publishing]\n\n# create the source distribution and the wheel\npython -m build\n\n# upload to test pypi instance (requires credentials)\npython -m twine upload --repository testpypi dist/*\n</code></pre> <p>Visit https://test.pypi.org/</p> <p>and verify that your package was uploaded successfully. Keep the terminal open, we\u2019ll need it later.</p> <p>In a new terminal, without an activated virtual environment or an env directory:</p> <pre><code>cd $(mktemp -d mibiremo-test.XXXXXX)\n\n# prepare a clean virtual environment and activate it\npython -m venv env\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip\n\n# install from test pypi instance:\npython -m pip -v install --no-cache-dir \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple mibiremo\n</code></pre> <p>Check that the package works as it should when installed from pypitest.</p> <p>Then upload to pypi.org with:</p> <pre><code># Back to the first terminal,\n# FINAL STEP: upload to PyPI (requires credentials)\npython -m twine upload dist/*\n</code></pre>"},{"location":"development/#33-github","title":"(3/3) GitHub","text":"<p>Don\u2019t forget to also make a release on GitHub. If your repository uses the GitHub-Zenodo integration this will also trigger Zenodo into making a snapshot of your repository and sticking a DOI on it.</p>"},{"location":"examples/","title":"MiBiReMo - Examples","text":"<p>Currently, three examples are available.  To run the examples, navigate to the <code>examples</code> directory and run the desired example script: <pre><code>cd path/to/project_folder\nsource mibiremo/bin/activate\ncd path/to/mibiremo_source/examples\npython ex1-titration.py\n</code></pre></p>"},{"location":"examples/#example-1-titration","title":"Example 1 - Titration","text":"<p>The first example <code>ex1-titration.py</code> demonstrates the use of the package to simulate a simple titration in a batch, where a solution is equilibrated with a mineral phase (calcite) and the pH is adjusted by adding HCl.</p>"},{"location":"examples/#example-2-benzene-and-ethylbenzene-kinetic-dissolution","title":"Example 2 - Benzene and Ethylbenzene kinetic dissolution","text":"<p>The second example <code>ex2-BTEX_dissolution.py</code> demonstrates the use of the package to simulate the kinetic dissolution of benzene and ethylbenzene in a batch reactor.</p>"},{"location":"examples/#example-3-reactive-transport-btex-dissolution-and-transport","title":"Example 3 - Reactive transport - BTEX dissolution and transport","text":"<p>The third example <code>ex3-BTEX_dissolution_transport_coupling.py</code> demonstrates the use of the package to simulate the reactive transport of benzene and ethylbenzene in a 1D domain. The problem is described in the following scheme:</p> <p></p> <p>The model consists of a 1D domain with a length of 50 m. The domain is initially filled with clean groundwater with a spot of benzene and ethylbenzene pure phases present at the left side of the domain extending for 0.5 m. We assumed that the contaminant pure phase in the source zone is immobile (it only dissolves). The groundwater flows from left to right with a velocity of 1 m/d, and dissolved benzene and ethylbenzene are transported towards the right end of the domain. The dissolution process is modelled both kinetically and equilibrium-based.  The model is run for 100 days, and the concentration of benzene and ethylbenzene is monitored at the right side of the domain.</p> <p>Three simulation runs are performed: 1. Equilibrium dissolution of benzene and ethylbenzene simulated with PHREEQC (standalone). 2. Equilibrium dissolution of benzene and ethylbenzene simulated by MiBiReMo (1D transport solver coupled with PhreeqcRM). 3. Kinetic dissolution of benzene and ethylbenzene simulated by MiBiReMo.</p> <p>The transport equition (advection and dispersion) in MiBiReMo is solved using a Semi-Lagrangian scheme with operator splitting, where the advection is solved using the method of characteristics with cubic spline interpolation, and the dispersion is solved using the Saul\u2019yev finite differences technique. </p> <p>Simulation results are shown in the following figure:</p> <p></p> <p>The results obtaines show a pattern similar to the experimental results obtained by Geller and Hunt (1993) [1]. In their experiment they injected an equimolar mixture of benzene and toluene in the center of a column which was subsequently eluted with water. The results show that benzene is eluted first, followed by toluene because of the different solubilities. The following figure shows the experimental results obtained by Geller and Hunt (1993):</p> <p></p>"},{"location":"examples/#references","title":"References","text":"<p>[1] Geller, J. T., and J. R. Hunt (1993), Mass transfer from nonaqueous phase organic liquids in water-saturated porous media, Water Resour. Res., 29(4), 833\u2013845, doi:10.1029/92WR02581. </p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#general","title":"General","text":"<p>MiBiReMo (Microbiome Bioremediation Reaction Module) is a Python interface to the PhreeqcRM library. The package is designed to be coupled with transport models to simulate reactive transport in porous media, with applications in environmental and geochemical engineering.</p>"},{"location":"introduction/#mibirem","title":"MIBIREM","text":"<p>MIBIREM - Innovative technological toolbox for bioremediation is a EU funded consortium project by 12 international partners all over Europe working together to develop an Innovative technological toolbox for bioremediation. The project will develop molecular methods for the monitoring, isolation, cultivation and subsequent deposition of whole microbiomes. The toolbox will also include the methodology for the improvement of specific microbiome functions, including evolution and enrichment. The performance of selected microbiomes will be tested under real field conditions. The <code>mibiremo</code> package is part of this toolbox.</p>"},{"location":"reference/","title":"<code>mibiremo</code> API reference","text":""},{"location":"reference/#mibiremo.irmresult","title":"<code>irmresult</code>","text":"<p>PhreeqcRM result code mapping and error handling utilities.</p> <p>This module provides utilities for interpreting and handling result codes returned by PhreeqcRM operations. PhreeqcRM functions return integer status codes that indicate success, failure, or specific error conditions. This module maps these numeric codes to human-readable error messages for improved debugging and logging.</p> <p>The result codes follow the PhreeqcRM C++ library conventions and correspond to the IrmResult enumeration defined in IrmResult.h of the original PhreeqcRM source code.</p> <p>Classes:</p> Name Description <code>IRMStatus</code> <p>Named tuple containing status code, name, and message with convenience methods.</p> <p>Functions:</p> Name Description <code>IRM_RESULT</code> <p>Maps integer error codes to IRMStatus objects with enhanced functionality.</p> <p>References:</p> <ul> <li>PhreeqcRM IrmResult.h File Reference</li> </ul>"},{"location":"reference/#mibiremo.irmresult.IRMStatus","title":"<code>IRMStatus</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>PhreeqcRM status result with enhanced functionality.</p> <p>This named tuple extends the basic error code mapping with convenience methods for better error handling and user experience.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>The raw integer error code from PhreeqcRM.</p> <code>name</code> <code>str</code> <p>Symbolic name of the error code (e.g., \u201cIRM_OK\u201d, \u201cIRM_FAIL\u201d).</p> <code>message</code> <code>str</code> <p>Human-readable description of the error.</p> Source code in <code>mibiremo/irmresult.py</code> <pre><code>class IRMStatus(NamedTuple):\n    \"\"\"PhreeqcRM status result with enhanced functionality.\n\n    This named tuple extends the basic error code mapping with convenience methods\n    for better error handling and user experience.\n\n    Attributes:\n        code (int): The raw integer error code from PhreeqcRM.\n        name (str): Symbolic name of the error code (e.g., \"IRM_OK\", \"IRM_FAIL\").\n        message (str): Human-readable description of the error.\n    \"\"\"\n\n    code: int\n    name: str\n    message: str\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if the operation was successful (code == 0).\n\n        Examples:\n            &gt;&gt;&gt; result = rm.RM_RunCells()\n            &gt;&gt;&gt; if result:\n            &gt;&gt;&gt;     print(\"Success!\")\n            &gt;&gt;&gt; else:\n            &gt;&gt;&gt;     print(f\"Error: {result}\")\n        \"\"\"\n        return self.code == 0\n\n    def __int__(self) -&gt; int:\n        \"\"\"Return the raw integer code for backwards compatibility.\n\n        Examples:\n            &gt;&gt;&gt; result = rm.RM_RunCells()\n            &gt;&gt;&gt; if int(result) == 0:  # Still works\n            &gt;&gt;&gt;     print(\"Success!\")\n        \"\"\"\n        return self.code\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a formatted string representation of the status.\n\n        Returns:\n            str: Formatted string in the form \"ERROR_NAME: Error description\"\n        \"\"\"\n        return f\"{self.name}: {self.message}\"\n\n    def raise_for_status(self, context: str = \"\") -&gt; None:\n        \"\"\"Raise an exception if the operation failed.\n\n        Args:\n            context (str, optional): Additional context for the error message.\n\n        Raises:\n            RuntimeError: If the status code indicates failure (non-zero).\n\n        Examples:\n            &gt;&gt;&gt; result = rm.RM_LoadDatabase(\"invalid.dat\")\n            &gt;&gt;&gt; result.raise_for_status(\"Loading database\")\n            RuntimeError: Loading database: IRM_FAIL: Failure, Unspecified\n        \"\"\"\n\n        if not self:\n            prefix = f\"{context}: \" if context else \"\"\n            raise RuntimeError(f\"{prefix}{self}\")\n</code></pre>"},{"location":"reference/#mibiremo.irmresult.IRMStatus.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the operation was successful (code == 0).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result = rm.RM_RunCells()\n&gt;&gt;&gt; if result:\n&gt;&gt;&gt;     print(\"Success!\")\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     print(f\"Error: {result}\")\n</code></pre> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return True if the operation was successful (code == 0).\n\n    Examples:\n        &gt;&gt;&gt; result = rm.RM_RunCells()\n        &gt;&gt;&gt; if result:\n        &gt;&gt;&gt;     print(\"Success!\")\n        &gt;&gt;&gt; else:\n        &gt;&gt;&gt;     print(f\"Error: {result}\")\n    \"\"\"\n    return self.code == 0\n</code></pre>"},{"location":"reference/#mibiremo.irmresult.IRMStatus.__int__","title":"<code>__int__()</code>","text":"<p>Return the raw integer code for backwards compatibility.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result = rm.RM_RunCells()\n&gt;&gt;&gt; if int(result) == 0:  # Still works\n&gt;&gt;&gt;     print(\"Success!\")\n</code></pre> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def __int__(self) -&gt; int:\n    \"\"\"Return the raw integer code for backwards compatibility.\n\n    Examples:\n        &gt;&gt;&gt; result = rm.RM_RunCells()\n        &gt;&gt;&gt; if int(result) == 0:  # Still works\n        &gt;&gt;&gt;     print(\"Success!\")\n    \"\"\"\n    return self.code\n</code></pre>"},{"location":"reference/#mibiremo.irmresult.IRMStatus.__str__","title":"<code>__str__()</code>","text":"<p>Return a formatted string representation of the status.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string in the form \u201cERROR_NAME: Error description\u201d</p> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a formatted string representation of the status.\n\n    Returns:\n        str: Formatted string in the form \"ERROR_NAME: Error description\"\n    \"\"\"\n    return f\"{self.name}: {self.message}\"\n</code></pre>"},{"location":"reference/#mibiremo.irmresult.IRMStatus.raise_for_status","title":"<code>raise_for_status(context='')</code>","text":"<p>Raise an exception if the operation failed.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Additional context for the error message.</p> <code>''</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the status code indicates failure (non-zero).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result = rm.RM_LoadDatabase(\"invalid.dat\")\n&gt;&gt;&gt; result.raise_for_status(\"Loading database\")\nRuntimeError: Loading database: IRM_FAIL: Failure, Unspecified\n</code></pre> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def raise_for_status(self, context: str = \"\") -&gt; None:\n    \"\"\"Raise an exception if the operation failed.\n\n    Args:\n        context (str, optional): Additional context for the error message.\n\n    Raises:\n        RuntimeError: If the status code indicates failure (non-zero).\n\n    Examples:\n        &gt;&gt;&gt; result = rm.RM_LoadDatabase(\"invalid.dat\")\n        &gt;&gt;&gt; result.raise_for_status(\"Loading database\")\n        RuntimeError: Loading database: IRM_FAIL: Failure, Unspecified\n    \"\"\"\n\n    if not self:\n        prefix = f\"{context}: \" if context else \"\"\n        raise RuntimeError(f\"{prefix}{self}\")\n</code></pre>"},{"location":"reference/#mibiremo.irmresult.IRM_RESULT","title":"<code>IRM_RESULT(code)</code>","text":"<p>Map PhreeqcRM integer error codes to enhanced status objects.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>Integer error code returned by PhreeqcRM functions. Return codes are listed below: - 0: Success (IRM_OK) - -1: Out of memory error - -2: Invalid variable type - -3: Invalid argument - -4: Invalid row index - -5: Invalid column index - -6: Invalid PhreeqcRM instance ID - -7: Unspecified failure</p> required <p>Returns:</p> Name Type Description <code>IRMStatus</code> <code>IRMStatus</code> <p>A named tuple containing: - code (int): The raw integer error code - name (str): Symbolic error code name (e.g., \u201cIRM_OK\u201d, \u201cIRM_FAIL\u201d) - message (str): Human-readable error description</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result = IRM_RESULT(0)\n&gt;&gt;&gt; print(result)  # \"IRM_OK: Success\"\n&gt;&gt;&gt; if result:  # True for success\n&gt;&gt;&gt;     print(\"Operation successful\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; error = IRM_RESULT(-1)\n&gt;&gt;&gt; print(int(error))  # -1 (backwards compatibility)\n&gt;&gt;&gt; error.raise_for_status(\"Memory allocation\")  # Raises RuntimeError\n</code></pre> Source code in <code>mibiremo/irmresult.py</code> <pre><code>def IRM_RESULT(code: int) -&gt; IRMStatus:\n    \"\"\"Map PhreeqcRM integer error codes to enhanced status objects.\n\n    Args:\n        code (int): Integer error code returned by PhreeqcRM functions.\n            Return codes are listed below:\n            - 0: Success (IRM_OK)\n            - -1: Out of memory error\n            - -2: Invalid variable type\n            - -3: Invalid argument\n            - -4: Invalid row index\n            - -5: Invalid column index\n            - -6: Invalid PhreeqcRM instance ID\n            - -7: Unspecified failure\n\n    Returns:\n        IRMStatus: A named tuple containing:\n            - code (int): The raw integer error code\n            - name (str): Symbolic error code name (e.g., \"IRM_OK\", \"IRM_FAIL\")\n            - message (str): Human-readable error description\n\n    Examples:\n        &gt;&gt;&gt; result = IRM_RESULT(0)\n        &gt;&gt;&gt; print(result)  # \"IRM_OK: Success\"\n        &gt;&gt;&gt; if result:  # True for success\n        &gt;&gt;&gt;     print(\"Operation successful\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; error = IRM_RESULT(-1)\n        &gt;&gt;&gt; print(int(error))  # -1 (backwards compatibility)\n        &gt;&gt;&gt; error.raise_for_status(\"Memory allocation\")  # Raises RuntimeError\n    \"\"\"\n    mapping = {\n        0: (\"IRM_OK\", \"Success\"),\n        -1: (\"IRM_OUTOFMEMORY\", \"Failure, Out of memory\"),\n        -2: (\"IRM_BADVARTYPE\", \"Failure, Invalid VAR type\"),\n        -3: (\"IRM_INVALIDARG\", \"Failure, Invalid argument\"),\n        -4: (\"IRM_INVALIDROW\", \"Failure, Invalid row\"),\n        -5: (\"IRM_INVALIDCOL\", \"Failure, Invalid column\"),\n        -6: (\"IRM_BADINSTANCE\", \"Failure, Invalid rm instance id\"),\n        -7: (\"IRM_FAIL\", \"Failure, Unspecified\"),\n    }\n\n    if code in mapping:\n        name, message = mapping[code]\n        return IRMStatus(code, name, message)\n    return IRMStatus(code, \"IRM_UNKNOWN\", f\"Unknown error code: {code}\")\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc","title":"<code>phreeqc</code>","text":"<p>Python interface to PhreeqcRM for geochemical reactive transport modeling.</p> <p>PhreeqcRM is a reaction module developed by the U.S. Geological Survey (USGS) for coupling geochemical calculations with transport models. It provides a high-performance interface to PHREEQC geochemical modeling capabilities for reactive transport simulations in environmental and hydrological applications.</p> <p>PhreeqcRM enables:</p> <ul> <li>Multi-threaded geochemical calculations for large-scale transport models</li> <li>Equilibrium and kinetic geochemical reactions in porous media</li> <li>Parallel processing for computationally intensive reactive transport</li> </ul> <p>This interface provides a Python wrapper around the PhreeqcRM C++ library, simplifying the process of integrating geochemical calculations with transport models.</p> <p>All RM_* methods in this class correspond directly to PhreeqcRM C++ functions. PhreeqcRM documentation and source code can be found at:</p> <ul> <li>PhreeqcRM Documentation</li> <li>PhreeqcRM GitHub Repository</li> </ul> <p>Last revision: 26/09/2025</p>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM","title":"<code>PhreeqcRM</code>","text":"<p>Python interface to PhreeqcRM for geochemical reactive transport modeling.</p> <p>This class facilitates coupling between transport codes and geochemical reaction calculations by managing multiple reaction cells, each representing a grid cell in the transport model. The PhreeqcRM approach allows efficient parallel processing of geochemical calculations across large spatial domains.</p> The class handles <ul> <li>Creation and initialization of PhreeqcRM instances</li> <li>Loading thermodynamic databases (PHREEQC format)</li> <li>Setting up initial chemical conditions from input files</li> <li>Running equilibrium and kinetic geochemical reactions</li> <li>Transferring concentrations between transport and reaction modules</li> <li>Managing porosity, saturation, temperature, and pressure fields</li> <li>Retrieving calculated properties and concentrations</li> </ul> Typical workflow <ol> <li>Create instance and call create() method to initialize with grid size</li> <li>Load thermodynamic database with initialize_phreeqc()</li> <li>Set initial conditions with run_initial_from_file()</li> <li>In transport time loop:</li> <li>Transfer concentrations to reaction module with RM_SetConcentrations()</li> <li>Advance time with RM_SetTime() and RM_SetTimeStep()</li> <li>Run reactions with RM_RunCells()</li> <li>Retrieve updated concentrations with RM_GetConcentrations()</li> </ol> <p>Attributes:</p> Name Type Description <code>dllpath</code> <code>str</code> <p>Path to the PhreeqcRM dynamic library file.</p> <code>nxyz</code> <code>int</code> <p>Number of grid cells in the reactive transport model.</p> <code>n_threads</code> <code>int</code> <p>Number of threads for parallel geochemical processing.</p> <code>libc</code> <code>CDLL</code> <p>Handle to the loaded PhreeqcRM dynamic library.</p> <code>id</code> <code>int</code> <p>Unique instance identifier returned by RM_Create.</p> <code>components</code> <code>ndarray</code> <p>Array of component names for transport.</p> <code>species</code> <code>ndarray</code> <p>Array of aqueous species names in the system.</p> Note <p>This interface requires the PhreeqcRM dynamic library to be available in the lib/ subdirectory. The library handles the underlying PHREEQC calculations and memory management.</p> <p>Examples:</p> <p>See page Examples for usage examples.</p> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>class PhreeqcRM:\n    \"\"\"Python interface to PhreeqcRM for geochemical reactive transport modeling.\n\n    This class facilitates coupling between transport codes and geochemical\n    reaction calculations by managing multiple reaction cells, each representing\n    a grid cell in the transport model. The PhreeqcRM approach allows efficient\n    parallel processing of geochemical calculations across large spatial domains.\n\n    The class handles:\n        - Creation and initialization of PhreeqcRM instances\n        - Loading thermodynamic databases (PHREEQC format)\n        - Setting up initial chemical conditions from input files\n        - Running equilibrium and kinetic geochemical reactions\n        - Transferring concentrations between transport and reaction modules\n        - Managing porosity, saturation, temperature, and pressure fields\n        - Retrieving calculated properties and concentrations\n\n    Typical workflow:\n        1. Create instance and call create() method to initialize with grid size\n        2. Load thermodynamic database with initialize_phreeqc()\n        3. Set initial conditions with run_initial_from_file()\n        4. In transport time loop:\n           - Transfer concentrations to reaction module with RM_SetConcentrations()\n           - Advance time with RM_SetTime() and RM_SetTimeStep()\n           - Run reactions with RM_RunCells()\n           - Retrieve updated concentrations with RM_GetConcentrations()\n\n    Attributes:\n        dllpath (str): Path to the PhreeqcRM dynamic library file.\n        nxyz (int): Number of grid cells in the reactive transport model.\n        n_threads (int): Number of threads for parallel geochemical processing.\n        libc (ctypes.CDLL): Handle to the loaded PhreeqcRM dynamic library.\n        id (int): Unique instance identifier returned by RM_Create.\n        components (numpy.ndarray): Array of component names for transport.\n        species (numpy.ndarray): Array of aqueous species names in the system.\n\n    Note:\n        This interface requires the PhreeqcRM dynamic library to be available\n        in the lib/ subdirectory. The library handles the underlying PHREEQC\n        calculations and memory management.\n\n    Examples:\n        See page [Examples](examples.md) for usage examples.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize PhreeqcRM instance.\n\n        Creates a new PhreeqcRM object with default values. The instance must be\n        created using the create() method before it can be used for calculations.\n        \"\"\"\n        self._initialized = False\n        self.dllpath = None\n        self.nxyz = 1\n        self.n_threads = 1\n        self.libc = None\n        self.id = None\n        self.components = None\n        self.species = None\n\n    def create(self, dllpath=None, nxyz=1, n_threads=1) -&gt; None:\n        \"\"\"Creates a PhreeqcRM reaction module instance.\n\n        Initializes the PhreeqcRM library, loads the dynamic library, and creates\n        a reaction module with the specified number of grid cells and threads.\n        This method must be called before any other PhreeqcRM operations.\n\n        Args:\n            dllpath (str, optional): Path to the PhreeqcRM library. If None,\n                uses the default library path based on the operating system.\n                Defaults to None.\n            nxyz (int, optional): Number of grid cells in the model. Must be\n                positive. Defaults to 1.\n            n_threads (int, optional): Number of threads for parallel processing.\n                Use -1 for automatic detection of CPU count. Defaults to 1.\n\n        Raises:\n            Exception: If the operating system is not supported (Windows/Linux only).\n            RuntimeError: If PhreeqcRM instance creation fails.\n\n        Examples:\n            &gt;&gt;&gt; rm = PhreeqcRM()\n            &gt;&gt;&gt; rm.create(nxyz=100, n_threads=4)\n        \"\"\"\n        if dllpath is None:\n            # If no path is provided, use the default path, based on operating system\n            if os.name == \"nt\":\n                dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.dll\")\n            elif os.name == \"posix\":\n                dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.so\")\n            else:\n                msg = \"Operating system not supported\"\n                raise Exception(msg)\n        self.dllpath = dllpath\n\n        if n_threads == -1:\n            n_threads = os.cpu_count()\n\n        self.n_threads = n_threads\n        self.nxyz = nxyz\n        self.libc = ctypes.CDLL(dllpath)\n        try:\n            self.id = self.libc.RM_Create(nxyz, n_threads)\n            self._initialized = True\n        except Exception as e:\n            msg = f\"Failed to create PhreeqcRM instance: {e}\"\n            raise RuntimeError(msg)\n\n    def initialize_phreeqc(\n        self,\n        database_path,\n        units_solution=2,\n        units=1,\n        porosity=1.0,\n        saturation=1.0,\n        multicomponent=True,\n    ) -&gt; None:\n        \"\"\"Initialize PhreeqcRM with database and default parameters.\n\n        Loads a thermodynamic database and sets up the PhreeqcRM instance with\n        standard parameters for geochemical calculations. This is a convenience\n        method that handles common initialization tasks.\n\n        Args:\n            database_path (str): Path to the PHREEQC database file (.dat format).\n                Common databases include phreeqc.dat, Amm.dat, pitzer.dat.\n            units_solution (int, optional): Units for solution concentrations.\n                1 = mol/L, 2 = mmol/L, 3 = \u03bcmol/L. Defaults to 2.\n            units (int, optional): Units for other phases (Exchange, Surface,\n                Gas, Solid solutions, Kinetics). Defaults to 1.\n            porosity (float, optional): Porosity value assigned to all cells.\n                Must be between 0 and 1. Defaults to 1.0.\n            saturation (float, optional): Saturation value assigned to all cells.\n                Must be between 0 and 1. Defaults to 1.0.\n            multicomponent (bool, optional): Enable multicomponent diffusion\n                by saving species concentrations. Defaults to True.\n\n        Raises:\n            RuntimeError: If the PhreeqcRM instance is not initialized or if\n                the database fails to load.\n\n        Examples:\n            &gt;&gt;&gt; rm = PhreeqcRM()\n            &gt;&gt;&gt; rm.create(nxyz=100)\n            &gt;&gt;&gt; rm.initialize_phreeqc(\"phreeqc.dat\", units_solution=1)\n        \"\"\"\n\n        if not self._initialized:\n            raise RuntimeError(\"PhreeqcRM instance not initialized. Call create() first.\")\n\n        # Load database\n        status = self.RM_LoadDatabase(database_path)\n        if not status:\n            raise RuntimeError(f\"Failed to load Phreeqc database: {status}\")\n\n        # Set properties/parameters\n        self.RM_SetComponentH2O(0)  # Don't include H2O in component list\n        self.RM_SetRebalanceFraction(0.5)  # Rebalance thread load\n\n        # Set units\n        self.RM_SetUnitsSolution(units_solution)\n        self.RM_SetUnitsPPassemblage(units)\n        self.RM_SetUnitsExchange(units)\n        self.RM_SetUnitsSurface(units)\n        self.RM_SetUnitsGasPhase(units)\n        self.RM_SetUnitsSSassemblage(units)\n        self.RM_SetUnitsKinetics(units)\n\n        # Set porosity and saturation\n        self.RM_SetPorosity(porosity * np.ones(self.nxyz))\n        self.RM_SetSaturation(saturation * np.ones(self.nxyz))\n\n        # Create error log files\n        self.RM_SetFilePrefix(\"phr\")\n        self.RM_OpenFiles()\n\n        # Multicomponent diffusion settings\n        if multicomponent:\n            self.RM_SetSpeciesSaveOn(1)\n\n    def run_initial_from_file(self, pqi_file, ic):\n        \"\"\"Set up initial conditions from PHREEQC input file and initial conditions array.\n\n        Loads initial geochemical conditions by running a PHREEQC input file and\n        mapping the defined solutions, phases, and other components to the grid cells.\n        This method also retrieves component and species information for later use.\n\n        Args:\n            pqi_file (str): Path to the PHREEQC input file (.pqi format) containing\n                definitions for solutions, equilibrium phases, exchange, surface,\n                gas phases, solid solutions, and kinetic reactions.\n            ic (numpy.ndarray): Initial conditions array with shape (nxyz, 7) where\n                each row corresponds to a grid cell and columns represent:\n                - Column 0: Solution ID\n                - Column 1: Equilibrium phase ID\n                - Column 2: Exchange ID\n                - Column 3: Surface ID\n                - Column 4: Gas phase ID\n                - Column 5: Solid solution ID\n                - Column 6: Kinetic reaction ID\n                Use -1 for unused components.\n\n        Raises:\n            RuntimeError: If the PHREEQC input file fails to run.\n            ValueError: If initial conditions array has incorrect shape or cannot\n                be converted to integer array.\n\n        Examples:\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; ic = np.array([[1, -1, -1, -1, -1, -1, -1]])  # Only solution 1\n            &gt;&gt;&gt; rm.run_initial_from_file(\"initial.pqi\", ic)\n        \"\"\"\n\n        # Run the initial setup file\n        status = self.RM_RunFile(1, 1, 1, pqi_file)\n        if not status:\n            raise RuntimeError(f\"Failed to run Phreeqc input file: {status}\")\n\n        # Check size of initial conditions array\n        if ic.shape != (self.nxyz, 7):\n            raise ValueError(f\"Initial conditions array must have shape ({self.nxyz}, 7), got {ic.shape}\")\n\n        # Be sure that ic is a numpy array\n        if not isinstance(ic, np.ndarray):\n            try:\n                ic = np.array(ic).astype(np.int32)\n            except Exception as e:\n                raise ValueError(\"Initial conditions must be convertible to a numpy array of integers\") from e\n\n        # Reshape initial conditions to 1D array\n        ic1 = np.reshape(ic.T, self.nxyz * 7).astype(np.int32)\n\n        # ic2 contains numbers for a second entity that mixes with the first entity (here, it is not used)\n        ic2 = -1 * np.ones(self.nxyz * 7, dtype=np.int32)\n\n        # f1 contains the fractions of the first entity in each cell (here, it is set to 1.0)\n        f1 = np.ones(self.nxyz * 7, dtype=np.float64)\n\n        status = self.RM_InitialPhreeqc2Module(ic1, ic2, f1)\n\n        # Get component and species information\n        n_comps = self.RM_FindComponents()\n        n_species = self.RM_GetSpeciesCount()\n\n        self.components = np.zeros(n_comps, dtype=\"U20\")\n        for i in range(n_comps):\n            self.RM_GetComponent(i, self.components, 20)\n\n        self.species = np.zeros(n_species, dtype=\"U20\")\n        for i in range(n_species):\n            self.RM_GetSpeciesName(i, self.species, 20)\n\n        # Run initial equilibrium step\n        self.RM_SetTime(0.0)\n        self.RM_SetTimeStep(0.0)\n        status = self.RM_RunCells()\n\n    def get_selected_output_df(self) -&gt; pd.DataFrame:\n        \"\"\"Retrieve selected output data as a pandas DataFrame.\n\n        Extracts the current selected output data from PhreeqcRM and formats it\n        as a pandas DataFrame with appropriate column headers. Selected output\n        typically includes calculated properties like pH, pe, ionic strength,\n        activities, saturation indices, and user-defined calculations.\n\n        Returns:\n            pandas.DataFrame: DataFrame containing selected output data with\n                rows representing grid cells and columns representing the\n                selected output variables defined in the PHREEQC input.\n\n        Examples:\n            &gt;&gt;&gt; df = rm.get_selected_output_df()\n            &gt;&gt;&gt; print(df.columns)  # Show available output variables\n            &gt;&gt;&gt; print(df['pH'])     # Access pH values for all cells\n        \"\"\"\n        # Get selected ouput headings\n        ncolsel = self.RM_GetSelectedOutputColumnCount()\n        selout_h = np.zeros(ncolsel, dtype=\"U100\")\n        for i in range(ncolsel):\n            self.RM_GetSelectedOutputHeading(i, selout_h, 100)\n        so = np.zeros(ncolsel * self.nxyz).reshape(self.nxyz, ncolsel)\n        self.RM_GetSelectedOutput(so)\n        return pd.DataFrame(so.reshape(ncolsel, self.nxyz).T, columns=selout_h)\n\n    ### PhreeqcRM functions\n    def RM_Abort(self, result, err_str):\n        \"\"\"Abort the PhreeqcRM run.\n\n        Args:\n            result (int): Error code indicating reason for abort.\n            err_str (str): Error message string.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_Abort(self.id, result, err_str))\n\n    def RM_CloseFiles(self):\n        \"\"\"Close output files opened by RM_OpenFiles.\n\n        Closes all output files that were opened by RM_OpenFiles, including\n        error logs and debug files. This method should be called before\n        destroying the PhreeqcRM instance to ensure proper file cleanup.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_OpenFiles()  # Open files for logging\n            &gt;&gt;&gt; # ... perform calculations ...\n            &gt;&gt;&gt; result = rm.RM_CloseFiles()  # Close files when done\n            &gt;&gt;&gt; if not result:\n            &gt;&gt;&gt;     print(f\"Warning: {result}\")\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_CloseFiles(self.id))\n\n    def RM_Concentrations2Utility(self, c, n, tc, p_atm):\n        \"\"\"Transfer concentrations from a cell to the utility IPhreeqc instance.\n\n        Transfers solution concentrations from a reaction cell to the utility\n        IPhreeqc instance for further calculations or analysis. This method\n        allows access to the full PHREEQC functionality for individual cells.\n\n        Args:\n            c (numpy.ndarray): Array of component concentrations to transfer.\n            n (int): Cell number from which to transfer concentrations.\n            tc (float): Temperature in Celsius for the utility calculation.\n            p_atm (float): Pressure in atmospheres for the utility calculation.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_Concentrations2Utility(self.id, c, n, tc, p_atm))\n\n    def RM_CreateMapping(self, grid2chem):\n        \"\"\"Create a mapping from grid cells to reaction cells.\n\n        Establishes the relationship between transport grid cells and reaction\n        cells, allowing for optimization when multiple grid cells share the\n        same chemical composition. This can significantly reduce computational\n        requirements for large models with repeating chemical conditions.\n\n        Args:\n            grid2chem (numpy.ndarray): Array mapping grid cells to reaction cells.\n                Length should equal the number of grid cells in the transport model.\n                Values are indices of reaction cells (0-based).\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            After calling this method, the number of reaction cells may be\n            different from the number of grid cells, potentially reducing\n            computational overhead.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_CreateMapping(self.id, grid2chem.ctypes))\n\n    def RM_DecodeError(self, e):\n        \"\"\"Decode error code to human-readable message.\n\n        Converts a numeric error code returned by PhreeqcRM functions into\n        a descriptive error message string for debugging and logging purposes.\n\n        Args:\n            e (int): Error code to decode.\n\n        Returns:\n            str: Human-readable error message corresponding to the error code.\n\n        Examples:\n            &gt;&gt;&gt; result = rm.RM_RunCells()\n            &gt;&gt;&gt; if not result:\n            &gt;&gt;&gt;     error_msg = rm.RM_DecodeError(result.code)\n            &gt;&gt;&gt;     print(f\"Error: {error_msg}\")\n        \"\"\"\n        return self.libc.RM_DecodeError(self.id, e)\n\n    def RM_Destroy(self):\n        \"\"\"Destroy a PhreeqcRM instance and free all associated memory.\n\n        Deallocates all memory associated with the PhreeqcRM instance, including\n        reaction cells, species data, and internal data structures. This method\n        should be called when the PhreeqcRM instance is no longer needed to\n        prevent memory leaks.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Warning:\n            After calling this method, the PhreeqcRM instance should not be\n            used for any further operations. All method calls will fail.\n\n        Examples:\n            &gt;&gt;&gt; rm = PhreeqcRM()\n            &gt;&gt;&gt; rm.create(nxyz=100)\n            &gt;&gt;&gt; # ... use PhreeqcRM instance ...\n            &gt;&gt;&gt; rm.RM_Destroy()  # Clean up when finished\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_Destroy(self.id))\n\n    def RM_DumpModule(self, dump_on, append):\n        \"\"\"Enable or disable dumping of reaction module data to file.\n        Controls the output of detailed reaction module data to a dump file\n        for debugging and analysis purposes. The dump file contains complete\n        information about the state of all reaction cells.\n\n        Args:\n            dump_on (int): Enable (1) or disable (0) dump file creation.\n            append (int): Append to existing file (1) or overwrite (0).\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            The dump file name is set by RM_SetDumpFileName(). If no name\n            is set, a default name will be used.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_DumpModule(self.id, dump_on, append))\n\n    def RM_ErrorMessage(self, errstr):\n        \"\"\"Print an error message to the error output file.\n\n        Writes an error message to the PhreeqcRM error log file. The message\n        is formatted with timestamp and process information for debugging.\n\n        Args:\n            errstr (str): Error message string to write to the log.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Error logging must be enabled with RM_OpenFiles() for messages\n            to be written to file.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_ErrorMessage(self.id, errstr))\n\n    def RM_FindComponents(self):\n        \"\"\"Find and count components for transport calculations.\n\n        Analyzes all chemical definitions in the reaction module to determine\n        the minimum set of components (elements plus charge) required for\n        transport calculations. This method must be called after initial\n        conditions are set but before starting transport calculations.\n\n        The components identified include:\n            - Chemical elements present in the system\n            - Electric charge balance\n            - Isotopes if defined in the database\n\n        Returns:\n            int: Number of components required for transport calculations.\n                This defines the number of concentrations that must be\n                transported for each grid cell.\n\n        Note:\n            This method should be called after RM_InitialPhreeqc2Module()\n            and before beginning transport time stepping. The returned\n            count determines array sizes for concentration transfers.\n\n        Examples:\n            &gt;&gt;&gt; rm.run_initial_from_file(\"initial.pqi\", ic_array)\n            &gt;&gt;&gt; ncomp = rm.RM_FindComponents()\n            &gt;&gt;&gt; print(f\"Transport requires {ncomp} components\")\n        \"\"\"\n        return self.libc.RM_FindComponents(self.id)\n\n    def RM_GetBackwardMapping(self, n, list, size):\n        \"\"\"Get backward mapping from reaction cells to grid cells.\n\n        Retrieves the list of grid cell numbers that map to a specific\n        reaction cell. This is the inverse of the forward mapping and is\n        useful for distributing reaction cell results back to grid cells.\n\n        Args:\n            n (int): Reaction cell number for which to get the mapping.\n            list (numpy.ndarray): Array to receive grid cell numbers that\n                map to the specified reaction cell.\n            size (int): Size of the list array.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n                The number of grid cells mapping to reaction cell n.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetBackwardMapping(self.id, n, list, size))\n\n    def RM_GetChemistryCellCount(self):\n        \"\"\"Get the number of reaction cells in the module.\n\n        Returns the number of reaction cells currently defined in the\n        PhreeqcRM instance. This may be different from the number of\n        grid cells if a mapping has been created to reduce computational\n        requirements by grouping cells with identical chemistry.\n\n        Returns:\n            int: Number of reaction cells in the module.\n\n        Note:\n            Without cell mapping, this equals the number of grid cells.\n            With mapping, this may be significantly smaller, improving\n            computational efficiency.\n        \"\"\"\n        return self.libc.RM_GetChemistryCellCount(self.id)\n\n    def RM_GetComponent(self, num, chem_name, length):\n        \"\"\"Get the name of a component by index.\n\n        Retrieves the name of a transport component identified by its index.\n        Components are the chemical entities that must be transported in\n        reactive transport simulations, typically elements plus charge.\n\n        Args:\n            num (int): Index of the component (0-based).\n            chem_name (numpy.ndarray): String array to store component names.\n                The name will be stored at index num.\n            length (int): Maximum length of the component name string.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            This method is typically used in a loop to retrieve all component\n            names after calling RM_FindComponents().\n        \"\"\"\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetComponent(self.id, num, String, length)\n        chem_name[num] = String.value.decode()\n        return IRM_RESULT(status)\n\n    def RM_GetConcentrations(self, c):\n        \"\"\"Retrieve component concentrations from reaction cells.\n\n        Extracts current component concentrations from all reaction cells\n        after geochemical calculations. These concentrations represent the\n        dissolved components that must be transported in reactive transport\n        simulations.\n\n        Args:\n            c (numpy.ndarray): Array to receive concentrations with shape\n                (nxyz * ncomps). Will be filled with current concentrations\n                in the units specified by RM_SetUnitsSolution().\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            The array is organized with all components for cell 0, followed\n            by all components for cell 1, etc. Use this method after\n            RM_RunCells() to get updated concentrations for transport.\n\n        Examples:\n            &gt;&gt;&gt; ncomp = rm.RM_GetComponentCount()\n            &gt;&gt;&gt; conc = np.zeros(nxyz * ncomp)\n            &gt;&gt;&gt; result = rm.RM_GetConcentrations(conc)\n            &gt;&gt;&gt; if result:\n            &gt;&gt;&gt;     # Reshape to (nxyz, ncomp) for easier handling\n            &gt;&gt;&gt;     conc_2d = conc.reshape(nxyz, ncomp)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetConcentrations(self.id, c.ctypes))\n\n    def RM_GetDensity(self, density):\n        \"\"\"Get solution density for all reaction cells.\n\n        Retrieves the calculated solution density for each reaction cell\n        based on the current chemical composition, temperature, and pressure.\n        Densities are calculated using the thermodynamic database properties.\n\n        Args:\n            density (numpy.ndarray): Array to receive density values with\n                length equal to the number of reaction cells. Units are kg/L.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Density calculations depend on the thermodynamic database and\n            the specific solution composition. This method should be called\n            after RM_RunCells() to get current density values.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetDensity(self.id, density.ctypes))\n\n    def RM_GetEndCell(self, ec):\n        \"\"\"Get the ending cell number for the current MPI process.\n\n        In parallel (MPI) calculations, each process handles a subset of\n        reaction cells. This method returns the index of the last cell\n        handled by the current MPI process.\n\n        Args:\n            ec (ctypes pointer): Pointer to receive the ending cell index.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            For single-process calculations, this typically returns nxyz-1.\n            For MPI calculations, the range [start_cell, end_cell] defines\n            the cells handled by the current process.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetEndCell(self.id, ec))\n\n    def RM_GetEquilibriumPhaseCount(self):\n        \"\"\"Get the number of equilibrium phases defined in the system.\n\n        Returns the count of mineral phases that can potentially precipitate\n        or dissolve based on the thermodynamic database and initial conditions\n        defined in the PhreeqcRM instance.\n\n        Returns:\n            int: Number of equilibrium phases defined in the system.\n\n        Note:\n            This count includes all phases that have been referenced in\n            EQUILIBRIUM_PHASES blocks in the initial conditions, regardless\n            of whether they are currently present in any cells.\n        \"\"\"\n        return self.libc.RM_GetEquilibriumPhaseCount(self.id)\n\n    def RM_GetEquilibriumPhaseName(self, num, name, l1):\n        \"\"\"Get the name of an equilibrium phase by index.\n\n        Retrieves the name of a mineral phase that can precipitate or dissolve\n        in the geochemical system, identified by its index.\n\n        Args:\n            num (int): Index of the equilibrium phase (0-based).\n            name (ctypes pointer): Buffer to receive the phase name.\n            l1 (int): Maximum length of the name buffer.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetEquilibriumPhaseName(self.id, num, name, l1))\n\n    def RM_GetErrorString(self, errstr, length):\n        \"\"\"Get the current error string from PhreeqcRM.\n\n        Retrieves the most recent error message generated by PhreeqcRM\n        operations. This provides detailed information about the last\n        error that occurred during calculations.\n\n        Args:\n            errstr (ctypes pointer): Buffer to receive the error string.\n            length (int): Maximum length of the error string buffer.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetErrorString(self.id, errstr, length))\n\n    def RM_GetErrorStringLength(self):\n        \"\"\"Get the length of the current error string.\n\n        Returns the length of the error message string that can be retrieved\n        with RM_GetErrorString(). Use this to allocate appropriate buffer\n        size before calling RM_GetErrorString().\n\n        Returns:\n            int: Length of the current error string in characters.\n        \"\"\"\n        return self.libc.RM_GetErrorStringLength(self.id)\n\n    def RM_GetExchangeName(self, num, name, l1):\n        return self.libc.RM_GetExchangeName(self.id, num, name, l1)\n\n    def RM_GetExchangeSpeciesCount(self):\n        return self.libc.RM_GetExchangeSpeciesCount(self.id)\n\n    def RM_GetExchangeSpeciesName(self, num, name, l1):\n        return self.libc.RM_GetExchangeSpeciesName(self.id, num, name, l1)\n\n    def RM_GetFilePrefix(self, prefix, length):\n        return self.libc.RM_GetFilePrefix(self.id, prefix.encode(), length)\n\n    def RM_GetGasComponentsCount(self):\n        return self.libc.RM_GetGasComponentsCount(self.id)\n\n    def RM_GetGasComponentsName(self, nun, name, l1):\n        return self.libc.RM_GetGasComponentsName(self.id, nun, name, l1)\n\n    def RM_GetGfw(self, gfw):\n        \"\"\"Get gram formula weights for transport components.\n\n        Retrieves the gram formula weights (molecular weights) for all\n        transport components. These weights are used to convert between\n        molar and mass-based concentrations in transport calculations.\n\n        Args:\n            gfw (numpy.ndarray): Array to receive gram formula weights.\n                Length should equal the number of components. Units are g/mol.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            The gram formula weights correspond to the components identified\n            by RM_FindComponents() and can be retrieved by RM_GetComponent().\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetGfw(self.id, gfw.ctypes))\n\n    def RM_GetGridCellCount(self):\n        \"\"\"Get the number of grid cells in the model.\n\n        Returns the total number of grid cells defined for the transport\n        model, as specified when the PhreeqcRM instance was created.\n\n        Returns:\n            int: Number of grid cells in the transport model.\n\n        Note:\n            This is the nxyz parameter that was passed to RM_Create().\n            It represents the total number of cells in the transport grid,\n            which may be different from the number of reaction cells if\n            cell mapping is used.\n        \"\"\"\n        return self.libc.RM_GetGridCellCount(self.id)\n\n    def RM_GetIPhreeqcId(self, i):\n        return self.libc.RM_GetIPhreeqcId(self.id, i)\n\n    def RM_GetKineticReactionsCount(self):\n        return self.libc.RM_GetKineticReactionsCount(self.id)\n\n    def RM_GetKineticReactionsName(self, num, name, l1):\n        return self.libc.RM_GetKineticReactionsName(self.id, num, name, l1)\n\n    def RM_GetMpiMyself(self):\n        return self.libc.RM_GetMpiMyself(self.id)\n\n    def RM_GetMpiTasks(self):\n        return self.libc.RM_GetMpiTasks(self.id)\n\n    def RM_GetNthSelectedOutputUserNumber(self, n):\n        return self.libc.RM_GetNthSelectedOutputUserNumber(self.id, n)\n\n    def RM_GetSaturation(self, sat_calc):\n        \"\"\"Get saturation values for all reaction cells.\n\n        Retrieves the current saturation values for all reaction cells.\n        Saturation represents the fraction of pore space occupied by water\n        and affects the volume calculations in reactive transport.\n\n        Args:\n            sat_calc (numpy.ndarray): Array to receive saturation values.\n                Length should equal the number of reaction cells.\n                Values range from 0 to 1.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSaturation(self.id, sat_calc.ctypes))\n\n    def RM_GetSelectedOutput(self, so):\n        \"\"\"Retrieve selected output data from all reaction cells.\n\n        Extracts the current selected output data, which includes calculated\n        properties such as pH, pe, ionic strength, mineral saturation indices,\n        species activities, and user-defined calculations specified in the\n        PHREEQC input files.\n\n        Args:\n            so (numpy.ndarray): Array to receive selected output data with\n                shape (nxyz, ncol) where ncol is the number of selected\n                output columns defined in the PHREEQC input.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Use RM_GetSelectedOutputColumnCount() to determine the number\n            of columns and RM_GetSelectedOutputHeading() to get column names.\n            The get_selected_output_df() method provides a more convenient pandas\n            DataFrame interface to this data.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSelectedOutput(self.id, so.ctypes))\n\n    def RM_GetNthSelectedOutputColumnCount(self):\n        return self.libc.RM_GetNthSelectedOutputColumnCount(self.id)\n\n    def RM_GetSelectedOutputCount(self):\n        return self.libc.RM_GetSelectedOutputCount(self.id)\n\n    def RM_GetSelectedOutputHeading(self, col, headings, length):\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetSelectedOutputHeading(self.id, col, String, length)\n        headings[col] = String.value.decode()\n        return IRM_RESULT(status)\n\n    def RM_GetSelectedOutputColumnCount(self):\n        \"\"\"Get number of columns in selected output.\n\n        Returns:\n            int: Number of selected output columns.\n        \"\"\"\n        return self.libc.RM_GetSelectedOutputColumnCount(self.id)\n\n    def RM_GetSelectedOutputRowCount(self):\n        \"\"\"Get number of rows in selected output.\n\n        Returns:\n            int: Number of selected output rows.\n        \"\"\"\n        return self.libc.RM_GetSelectedOutputRowCount(self.id)\n\n    def RM_GetSICount(self):\n        return self.libc.RM_GetSICount(self.id)\n\n    def RM_GetSIName(self, num, name, l1):\n        return self.libc.RM_GetSIName(self.id, num, name, l1)\n\n    def RM_GetSolidSolutionComponentsCount(self):\n        return self.libc.RM_GetSolidSolutionComponentsCount(self.id)\n\n    def RM_GetSolidSolutionComponentsName(self, num, name, l1):\n        return self.libc.RM_GetSolidSolutionComponentsName(self.id, num, name, l1)\n\n    def RM_GetSolidSolutionName(self, num, name, l1):\n        return self.libc.RM_GetSolidSolutionName(self.id, num, name, l1)\n\n    def RM_GetSolutionVolume(self, vol):\n        return self.libc.RM_GetSolutionVolume(self.id, vol.ctypes)\n\n    def RM_GetSpeciesConcentrations(self, species_conc):\n        \"\"\"Retrieve aqueous species concentrations from reaction cells.\n\n        Extracts the concentrations of individual aqueous species from all\n        reaction cells. This provides more detailed chemical information than\n        component concentrations, including the speciation of dissolved elements.\n\n        Args:\n            species_conc (numpy.ndarray): Array to receive species concentrations\n                with shape (nxyz * nspecies). Species concentrations are in\n                the same units as solution concentrations (mol/L, mmol/L, or \u03bcmol/L).\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Species saving must be enabled with RM_SetSpeciesSaveOn(1) before\n            this method can be used. Use RM_GetSpeciesCount() to determine the\n            number of species and RM_GetSpeciesName() to get species names.\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetSpeciesSaveOn(1)  # Enable species saving\n            &gt;&gt;&gt; rm.RM_RunCells()  # Run reactions\n            &gt;&gt;&gt; nspecies = rm.RM_GetSpeciesCount()\n            &gt;&gt;&gt; species_c = np.zeros(nxyz * nspecies)\n            &gt;&gt;&gt; rm.RM_GetSpeciesConcentrations(species_c)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSpeciesConcentrations(self.id, species_conc.ctypes))\n\n    def RM_GetSpeciesCount(self):\n        \"\"\"Get the number of aqueous species in the geochemical system.\n\n        Returns the total number of dissolved aqueous species that can exist\n        in the current geochemical system based on the loaded thermodynamic\n        database and the chemical components present in the system.\n\n        Returns:\n            int: Number of aqueous species defined in the system. This includes\n                primary species (elements and basis species) and secondary species\n                (complexes) formed from the primary species.\n\n        Note:\n            The species count is determined after loading the database and\n            running initial equilibrium calculations. Species names can be\n            retrieved using RM_GetSpeciesName() with indices from 0 to count-1.\n\n        Examples:\n            &gt;&gt;&gt; nspecies = rm.RM_GetSpeciesCount()\n            &gt;&gt;&gt; print(f\"System contains {nspecies} aqueous species\")\n            &gt;&gt;&gt; # Get all species names\n            &gt;&gt;&gt; species_names = np.zeros(nspecies, dtype='U20')\n            &gt;&gt;&gt; for i in range(nspecies):\n            &gt;&gt;&gt;     rm.RM_GetSpeciesName(i, species_names, 20)\n        \"\"\"\n        return self.libc.RM_GetSpeciesCount(self.id)\n\n    def RM_GetSpeciesD25(self, diffc):\n        \"\"\"Get diffusion coefficients at 25\u00b0C for all aqueous species.\n\n        Retrieves the reference diffusion coefficients (at 25\u00b0C in water)\n        for all aqueous species in the system. These values are used in\n        multicomponent diffusion calculations in reactive transport models.\n\n        Args:\n            diffc (numpy.ndarray): Array to receive diffusion coefficients\n                with length equal to the number of species. Units are m\u00b2/s.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Diffusion coefficients are taken from the thermodynamic database.\n            For transport at different temperatures, these values should be\n            corrected using appropriate temperature relationships.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSpeciesD25(self.id, diffc.ctypes))\n\n    def RM_GetSpeciesLog10Gammas(self, species_log10gammas):\n        \"\"\"Get log10 activity coefficients for all aqueous species.\n\n        Retrieves the base-10 logarithm of activity coefficients for all\n        aqueous species in each reaction cell. Activity coefficients account\n        for non-ideal solution behavior and are used to calculate activities\n        from concentrations.\n\n        Args:\n            species_log10gammas (numpy.ndarray): Array to receive log10 activity\n                coefficients with shape (nxyz * nspecies). Values are dimensionless.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Activity coefficients depend on ionic strength, temperature, and\n            the activity model used in the thermodynamic database (e.g.,\n            Debye-H\u00fcckel, Pitzer, SIT). Species saving must be enabled.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSpeciesLog10Gammas(self.id, species_log10gammas.ctypes))\n\n    def RM_GetSpeciesName(self, num, chem_name, length):\n        \"\"\"Get the name of an aqueous species by index.\n\n        Retrieves the name of an aqueous species identified by its index.\n        Species names follow PHREEQC conventions and include charge states\n        for ionic species.\n\n        Args:\n            num (int): Index of the species (0-based).\n            chem_name (numpy.ndarray): String array to store species names.\n                The name will be stored at index num.\n            length (int): Maximum length of the species name string.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Examples:\n            &gt;&gt;&gt; nspecies = rm.RM_GetSpeciesCount()\n            &gt;&gt;&gt; species_names = np.zeros(nspecies, dtype='U20')\n            &gt;&gt;&gt; for i in range(nspecies):\n            &gt;&gt;&gt;     rm.RM_GetSpeciesName(i, species_names, 20)\n            &gt;&gt;&gt; print(species_names)  # ['H2O', 'H+', 'OH-', 'Ca+2', ...]\n        \"\"\"\n        String = ctypes.create_string_buffer(length)\n        status = self.libc.RM_GetSpeciesName(self.id, num, String, length)\n        chem_name[num] = String.value.decode()\n        return IRM_RESULT(status)\n\n    def RM_GetSpeciesSaveOn(self):\n        \"\"\"Check if species concentration saving is enabled.\n\n        Returns the current setting for species concentration saving. When\n        enabled, PhreeqcRM calculates and stores individual species\n        concentrations that can be retrieved with RM_GetSpeciesConcentrations().\n\n        Returns:\n            int: 1 if species saving is enabled, 0 if disabled.\n\n        Note:\n            Species saving increases memory usage and computation time but\n            provides detailed speciation information useful for analysis\n            and multicomponent diffusion calculations.\n        \"\"\"\n        return self.libc.RM_GetSpeciesSaveOn(self.id)\n\n    def RM_GetSpeciesZ(self, Z):\n        \"\"\"Get charge values for all aqueous species.\n\n        Retrieves the electric charge (valence) for each aqueous species\n        in the system. Charge values are essential for electrostatic\n        calculations and charge balance constraints.\n\n        Args:\n            Z (numpy.ndarray): Array to receive charge values with length\n                equal to the number of species. Values are dimensionless\n                (e.g., +2 for Ca+2, -1 for Cl-, 0 for neutral species).\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Charge values are defined in the thermodynamic database and\n            are used in activity coefficient calculations and electroneutrality\n            constraints.\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_GetSpeciesZ(self.id, Z.ctypes))\n\n    def RM_GetStartCell(self, sc):\n        return self.libc.RM_GetStartCell(self.id, sc)\n\n    def RM_GetSurfaceName(self, num, name, l1):\n        return self.libc.RM_GetSurfaceName(self.id, num, name, l1)\n\n    def RM_GetSurfaceType(self, num, name, l1):\n        return self.libc.RM_GetSurfaceType(self.id, num, name, l1)\n\n    def RM_GetThreadCount(self):\n        return self.libc.RM_GetThreadCount(self.id)\n\n    def RM_GetTime(self):\n        \"\"\"Get the current simulation time.\n\n        Returns the current time in the reactive transport simulation.\n        This time is used for kinetic rate calculations and time-dependent\n        boundary conditions.\n\n        Returns:\n            float: Current simulation time in user-defined units (typically\n                seconds, days, or years depending on the model setup).\n\n        Note:\n            The simulation time is set by RM_SetTime() and is used internally\n            by PhreeqcRM for kinetic calculations. The time units should be\n            consistent with kinetic rate constants in the database.\n\n        Examples:\n            &gt;&gt;&gt; current_time = rm.RM_GetTime()\n            &gt;&gt;&gt; print(f\"Current simulation time: {current_time} days\")\n        \"\"\"\n        self.libc.RM_GetTime.restype = ctypes.c_double\n        return self.libc.RM_GetTime(self.id)\n\n    def RM_GetTimeConversion(self):\n        self.libc.RM_GetTimeConversion.restype = ctypes.c_double\n        return self.libc.RM_GetTimeConversion(self.id)\n\n    def RM_GetTimeStep(self):\n        \"\"\"Get the current time step duration.\n\n        Returns the duration of the current time step used for kinetic\n        calculations and time-dependent processes in the geochemical system.\n\n        Returns:\n            float: Current time step duration in user-defined units (typically\n                seconds, days, or years consistent with the simulation time units).\n\n        Note:\n            The time step is set by RM_SetTimeStep() and affects the integration\n            of kinetic rate equations. Smaller time steps provide more accurate\n            solutions but require more computational time.\n\n        Examples:\n            &gt;&gt;&gt; dt = rm.RM_GetTimeStep()\n            &gt;&gt;&gt; print(f\"Current time step: {dt} days\")\n        \"\"\"\n        self.libc.RM_GetTimeStep.restype = ctypes.c_double\n        return self.libc.RM_GetTimeStep(self.id)\n\n    def RM_InitialPhreeqc2Module(self, ic1, ic2, f1):\n        \"\"\"Transfer initial conditions from InitialPhreeqc to reaction module.\n\n        Args:\n            ic1 (numpy.ndarray): Initial condition indices for primary entities.\n            ic2 (numpy.ndarray): Initial condition indices for secondary entities.\n            f1 (numpy.ndarray): Mixing fractions for primary entities.\n\n        Returns:\n            int: IRM_RESULT status code (0 for success).\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_InitialPhreeqc2Module(self.id, ic1.ctypes, ic2.ctypes, f1.ctypes))\n\n    def RM_InitialPhreeqc2Concentrations(self, c, n_boundary, boundary_solution1, boundary_solution2, fraction1):\n        return self.libc.RM_InitialPhreeqc2Concentrations(\n            self.id, c.ctypes, n_boundary, boundary_solution1.ctypes, boundary_solution2.ctypes, fraction1.ctypes\n        )\n\n    def RM_InitialPhreeqc2SpeciesConcentrations(\n        self, species_c, n_boundary, boundary_solution1, boundary_solution2, fraction1\n    ):\n        return self.libc.RM_InitialPhreeqc2SpeciesConcentrations(\n            self.id,\n            species_c.ctypes,\n            n_boundary.ctypes,\n            boundary_solution1.ctypes,\n            boundary_solution2.ctypes,\n            fraction1.ctypes,\n        )\n\n    def RM_InitialPhreeqcCell2Module(self, n, module_numbers, dim_module_numbers):\n        return self.libc.RM_InitialPhreeqcCell2Module(self.id, n, module_numbers, dim_module_numbers)\n\n    def RM_LoadDatabase(self, db_name):\n        \"\"\"Load a thermodynamic database for geochemical calculations.\n\n        Loads a PHREEQC-format thermodynamic database containing thermodynamic\n        data for aqueous species, minerals, gases, and other phases. The database\n        defines the chemical system and enables geochemical calculations.\n\n        Args:\n            db_name (str): Path to the database file. Common databases include:\n                - \"phreeqc.dat\": Standard PHREEQC database (25\u00b0C)\n                - \"Amm.dat\": Extended database with ammonia species\n                - \"pitzer.dat\": Pitzer interaction parameter database\n                - \"sit.dat\": Specific ion interaction theory database\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Raises:\n            RuntimeError: If the database file cannot be found or loaded.\n\n        Note:\n            This method must be called before setting up initial conditions\n            or running calculations. The database determines which species,\n            minerals, and reactions are available for calculations.\n\n        Examples:\n            &gt;&gt;&gt; rm = PhreeqcRM()\n            &gt;&gt;&gt; rm.create(nxyz=100)\n            &gt;&gt;&gt; result = rm.RM_LoadDatabase(\"phreeqc.dat\")\n            &gt;&gt;&gt; if not result:\n            &gt;&gt;&gt;     raise RuntimeError(f\"Failed to load database: {result}\")\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_LoadDatabase(self.id, db_name.encode()))\n\n    def RM_LogMessage(self, str):\n        return self.libc.RM_LogMessage(self.id, str.encode())\n\n    def RM_MpiWorker(self):\n        return self.libc.RM_MpiWorker(self.id)\n\n    def RM_MpiWorkerBreak(self):\n        return self.libc.RM_MpiWorkerBreak(self.id)\n\n    def RM_OpenFiles(self):\n        \"\"\"Open output files for logging, debugging, and error reporting.\n\n        Creates and opens output files for PhreeqcRM logging, error messages,\n        and debugging information. File names are based on the prefix set\n        by RM_SetFilePrefix().\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Files created:\n            - {prefix}.log: General log messages and information\n            - {prefix}.err: Error messages and warnings\n            - {prefix}.out: PHREEQC output from calculations\n\n        Note:\n            Call RM_SetFilePrefix() before this method to set the file name\n            prefix. Use RM_CloseFiles() to properly close files when finished.\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetFilePrefix(\"simulation\")\n            &gt;&gt;&gt; rm.RM_OpenFiles()  # Creates simulation.log, simulation.err, etc.\n            &gt;&gt;&gt; # ... run calculations ...\n            &gt;&gt;&gt; rm.RM_CloseFiles()  # Clean up\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_OpenFiles(self.id))\n\n    def RM_OutputMessage(self, str):\n        return self.libc.RM_OutputMessage(self.id, str.encode())\n\n    def RM_RunCells(self):\n        \"\"\"Run geochemical reactions for all reaction cells.\n\n        Performs equilibrium speciation and kinetic reactions for the current\n        time step in all reaction cells. This is the core computational method\n        that updates chemical compositions based on thermodynamic equilibrium\n        and reaction kinetics.\n\n        The method performs:\n            - Aqueous speciation calculations\n            - Mineral precipitation/dissolution equilibrium\n            - Ion exchange equilibrium\n            - Surface complexation equilibrium\n            - Gas phase equilibrium\n            - Kinetic reaction integration over the time step\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Before calling this method, ensure that:\n            - Concentrations are set with RM_SetConcentrations()\n            - Current time is set with RM_SetTime()\n            - Time step is set with RM_SetTimeStep()\n            - Temperature and pressure are set if needed\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetConcentrations(concentrations)\n            &gt;&gt;&gt; rm.RM_SetTime(current_time)\n            &gt;&gt;&gt; rm.RM_SetTimeStep(dt)\n            &gt;&gt;&gt; result = rm.RM_RunCells()\n            &gt;&gt;&gt; if result:\n            &gt;&gt;&gt;     rm.RM_GetConcentrations(updated_concentrations)\n            &gt;&gt;&gt; else:\n            &gt;&gt;&gt;     print(f\"Reaction failed: {result}\")\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_RunCells(self.id))\n\n    def RM_RunFile(self, workers, initial_phreeqc, utility, chem_name):\n        \"\"\"Run a PHREEQC input file in specified PhreeqcRM instances.\n\n        Executes a PHREEQC input file (.pqi format) in one or more PhreeqcRM\n        instances. This is used to define initial conditions, equilibrium phases,\n        exchange assemblages, surface complexation sites, gas phases, solid\n        solutions, and kinetic reactions.\n\n        Args:\n            workers (int): Run in worker instances (1) or not (0). Worker instances\n                handle the main geochemical calculations for reaction cells.\n            initial_phreeqc (int): Run in initial PhreeqcRM instance (1) or not (0).\n                Used for defining initial chemical conditions and templates.\n            utility (int): Run in utility instance (1) or not (0). Utility instance\n                provides access to full PHREEQC functionality for special calculations.\n            chem_name (str): Path to the PHREEQC input file containing chemical\n                definitions and calculations.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            PHREEQC input files define the chemical system using standard PHREEQC\n            syntax. Common blocks include SOLUTION, EQUILIBRIUM_PHASES, EXCHANGE,\n            SURFACE, GAS_PHASE, SOLID_SOLUTIONS, KINETICS, and SELECTED_OUTPUT.\n\n        Examples:\n            &gt;&gt;&gt; # Run initial conditions file in initial PhreeqcRM instance\n            &gt;&gt;&gt; result = rm.RM_RunFile(0, 1, 0, \"initial_conditions.pqi\")\n            &gt;&gt;&gt; if not result:\n            &gt;&gt;&gt;     print(f\"Error running initial conditions file: {result}\")\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_RunFile(self.id, workers, initial_phreeqc, utility, chem_name.encode()))\n\n    def RM_RunString(self, workers, initial_phreeqc, utility, input_string):\n        \"\"\"Run PHREEQC input from a string in specified instances.\n\n        Executes PHREEQC input commands provided as a string in one or more\n        PhreeqcRM instances. This allows dynamic generation of PHREEQC input\n        without creating temporary files.\n\n        Args:\n            workers (int): Run in worker instances (1) or not (0).\n            initial_phreeqc (int): Run in initial PhreeqcRM instance (1) or not (0).\n            utility (int): Run in utility instance (1) or not (0).\n            input_string (str): PHREEQC input commands as a string, using\n                standard PHREEQC syntax with newline separators.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Examples:\n            &gt;&gt;&gt; phreeqc_input = '''\n            &gt;&gt;&gt; SOLUTION 1\n            &gt;&gt;&gt;     pH 7.0\n            &gt;&gt;&gt;     Ca 1.0\n            &gt;&gt;&gt;     Cl 2.0\n            &gt;&gt;&gt; END\n            &gt;&gt;&gt; '''\n            &gt;&gt;&gt; rm.RM_RunString(0, 1, 0, phreeqc_input)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_RunString(self.id, workers, initial_phreeqc, utility, input_string.encode()))\n\n    def RM_ScreenMessage(self, str):\n        return self.libc.RM_ScreenMessage(self.id, str.encode())\n\n    def RM_SetComponentH2O(self, tf):\n        \"\"\"Set whether to include H2O as a transport component.\n\n        Controls whether water (H2O) is included in the list of components\n        that must be transported in reactive transport simulations. This\n        setting affects the component count and transport requirements.\n\n        Args:\n            tf (int): Include H2O as a component:\n                1 = Include H2O as a transport component\n                0 = Exclude H2O from transport components (default)\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Typically, H2O is not transported as a separate component because\n            water content is determined by porosity, saturation, and density.\n            Including H2O increases the number of transport equations but may\n            be necessary for some specialized applications.\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetComponentH2O(0)  # Standard: don't transport H2O\n            &gt;&gt;&gt; ncomp = rm.RM_FindComponents()  # Get component count\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetComponentH2O(self.id, tf))\n\n    def RM_SetConcentrations(self, c):\n        \"\"\"Set component concentrations for all reaction cells.\n\n        Transfers concentration data from the transport model to the reaction\n        module. This method is typically called at each transport time step\n        to provide updated concentrations for geochemical calculations.\n\n        Args:\n            c (numpy.ndarray): Concentration array with shape (nxyz * ncomps)\n                containing concentrations for all cells and components.\n                Concentrations must be in the units specified by RM_SetUnitsSolution().\n                Array is organized with all components for cell 0, followed by\n                all components for cell 1, etc.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            This method sets the starting concentrations for the next call to\n            RM_RunCells(). The concentrations are used as initial conditions\n            for equilibrium and kinetic calculations.\n\n        Examples:\n            &gt;&gt;&gt; # Transport model updates concentrations\n            &gt;&gt;&gt; new_conc = transport_step(old_conc, velocity, dt)\n            &gt;&gt;&gt; # Transfer to reaction module\n            &gt;&gt;&gt; result = rm.RM_SetConcentrations(new_conc.flatten())\n            &gt;&gt;&gt; if result:\n            &gt;&gt;&gt;     rm.RM_RunCells()  # Run geochemical reactions\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetConcentrations(self.id, c.ctypes))\n\n    def RM_SetCurrentSelectedOutputUserNumber(self, n_user):\n        return self.libc.RM_SetCurrentSelectedOutputUserNumber(self.id, n_user)\n\n    def RM_SetDensity(self, density):\n        return self.libc.RM_SetDensity(self.id, density.ctypes)\n\n    def RM_SetDumpFileName(self, dump_name):\n        return self.libc.RM_SetDumpFileName(self.id, dump_name)\n\n    def RM_SetErrorHandlerMode(self, mode):\n        return self.libc.RM_SetErrorHandlerMode(self.id, mode)\n\n    def RM_SetFilePrefix(self, prefix):\n        \"\"\"Set prefix for output files.\n\n        Args:\n            prefix (str): Prefix string for output file names.\n\n        Returns:\n            int: IRM_RESULT status code (0 for success).\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetFilePrefix(self.id, prefix.encode()))\n\n    def RM_SetMpiWorkerCallbackCookie(self, cookie):\n        return self.libc.RM_SetMpiWorkerCallbackCookie(self.id, cookie)\n\n    def RM_SetPartitionUZSolids(self, tf):\n        return self.libc.RM_SetPartitionUZSolids(self.id, tf)\n\n    def RM_SetPorosity(self, por):\n        \"\"\"Set porosity values for all grid cells.\n\n        Defines the porosity (void fraction) for each grid cell, which\n        represents the fraction of bulk volume occupied by pore space.\n        Porosity affects volume calculations for concentration conversions\n        and reaction extent calculations.\n\n        Args:\n            por (numpy.ndarray): Array of porosity values for each cell.\n                Length should equal the number of grid cells (nxyz).\n                Values must be between 0 and 1, where:\n                - 0 = no pore space (solid rock)\n                - 1 = completely porous (pure fluid)\n                - Typical values: 0.1-0.4 for sedimentary rocks\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Porosity is used with saturation to calculate the water volume\n            in each cell: water_volume = porosity \u00d7 saturation \u00d7 bulk_volume.\n            This affects concentration calculations and reaction stoichiometry.\n\n        Examples:\n            &gt;&gt;&gt; porosity = np.full(nxyz, 0.25)  # 25% porosity for all cells\n            &gt;&gt;&gt; rm.RM_SetPorosity(porosity)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetPorosity(self.id, por.ctypes))\n\n    def RM_SetPressure(self, p):\n        return self.libc.RM_SetPressure(self.id, p.ctypes)\n\n    def RM_SetPrintChemistryMask(self, cell_mask):\n        return self.libc.RM_SetPrintChemistryMask(self.id, cell_mask.ctypes)\n\n    def RM_SetPrintChemistryOn(self, workers, initial_phreeqc, utility):\n        return self.libc.RM_SetPrintChemistryOn(self.id, workers, initial_phreeqc, utility)\n\n    def RM_SetRebalanceByCell(self, method):\n        return self.libc.RM_SetRebalanceByCell(self.id, method)\n\n    def RM_SetRebalanceFraction(self, f):\n        \"\"\"Set load balancing algorithm fraction.\n\n        Args:\n            f (float): Fraction for load balancing (typically 0.5).\n\n        Returns:\n            int: IRM_RESULT status code (0 for success).\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetRebalanceFraction(self.id, ctypes.c_double(f)))\n\n    def RM_SetRepresentativeVolume(self, rv):\n        return self.libc.RM_SetRepresentativeVolume(self.id, rv.ctypes)\n\n    def RM_SetSaturation(self, sat):\n        \"\"\"Set water saturation values for all grid cells.\n\n        Defines the water saturation for each grid cell, representing the\n        fraction of pore space occupied by water. Saturation affects volume\n        calculations and is particularly important in unsaturated zone\n        modeling where gas phase may occupy part of the pore space.\n\n        Args:\n            sat (numpy.ndarray): Array of saturation values for each cell.\n                Length should equal the number of grid cells (nxyz).\n                Values must be between 0 and 1, where:\n                - 0 = dry (no water in pores)\n                - 1 = fully saturated (all pores filled with water)\n                - Typical values: 0.1-1.0 depending on vadose zone conditions\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            Water saturation is used with porosity to calculate the actual\n            water volume: water_volume = porosity \u00d7 saturation \u00d7 bulk_volume.\n            This directly affects solution concentrations and reaction rates.\n\n        Examples:\n            &gt;&gt;&gt; # Fully saturated conditions\n            &gt;&gt;&gt; saturation = np.ones(nxyz)\n            &gt;&gt;&gt; rm.RM_SetSaturation(saturation)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Partially saturated (vadose zone)\n            &gt;&gt;&gt; sat_profile = np.linspace(0.3, 1.0, nxyz)  # Increasing with depth\n            &gt;&gt;&gt; rm.RM_SetSaturation(sat_profile)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetSaturation(self.id, sat.ctypes))\n\n    def RM_SetScreenOn(self, tf):\n        return self.libc.RM_SetScreenOn(self.id, tf)\n\n    def RM_SetSelectedOutputOn(self, selected_output):\n        return self.libc.RM_SetSelectedOutputOn(self.id, selected_output)\n\n    def RM_SetSpeciesSaveOn(self, save_on):\n        \"\"\"Enable or disable saving of aqueous species concentrations.\n\n        Controls whether PhreeqcRM calculates and stores individual aqueous\n        species concentrations that can be retrieved with RM_GetSpeciesConcentrations().\n        This provides detailed speciation information but increases memory usage\n        and computation time.\n\n        Args:\n            save_on (int): Species saving option:\n                1 = Enable species concentration saving\n                0 = Disable species saving (default, saves memory and time)\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            When enabled, PhreeqcRM stores concentrations for all aqueous species\n            after each call to RM_RunCells(). This is required for:\n            - Multicomponent diffusion calculations\n            - Detailed speciation analysis\n            - Species-specific output and post-processing\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetSpeciesSaveOn(1)  # Enable species saving\n            &gt;&gt;&gt; rm.RM_RunCells()  # Calculate with species saving\n            &gt;&gt;&gt; species_conc = np.zeros(nxyz * nspecies)\n            &gt;&gt;&gt; rm.RM_GetSpeciesConcentrations(species_conc)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetSpeciesSaveOn(self.id, save_on))\n\n    def RM_SetTemperature(self, t):\n        return self.libc.RM_SetTemperature(self.id, t.ctypes)\n\n    def RM_SetTime(self, time):\n        \"\"\"Set the current simulation time for geochemical calculations.\n\n        Updates the simulation time used by PhreeqcRM for kinetic rate\n        calculations and time-dependent processes. The time should be\n        consistent with the time stepping in the transport model.\n\n        Args:\n            time (float): Current simulation time in user-defined units.\n                Units should be consistent with kinetic rate constants\n                in the thermodynamic database (typically seconds, days, or years).\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            This method should be called before each call to RM_RunCells()\n            to ensure kinetic calculations use the correct time. The time\n            is used to integrate kinetic rate equations over the time step.\n\n        Examples:\n            &gt;&gt;&gt; for step in range(num_steps):\n            &gt;&gt;&gt;     current_time = step * dt\n            &gt;&gt;&gt;     rm.RM_SetTime(current_time)\n            &gt;&gt;&gt;     rm.RM_SetTimeStep(dt)\n            &gt;&gt;&gt;     rm.RM_RunCells()\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetTime(self.id, ctypes.c_double(time)))\n\n    def RM_SetTimeConversion(self, conv_factor):\n        return self.libc.RM_SetTimeConversion(self.id, ctypes.c_double(conv_factor))\n\n    def RM_SetTimeStep(self, time_step):\n        \"\"\"Set the time step duration for kinetic calculations.\n\n        Specifies the time interval over which kinetic reactions will be\n        integrated during the next call to RM_RunCells(). The time step\n        affects the accuracy of kinetic calculations.\n\n        Args:\n            time_step (float): Time step duration in user-defined units.\n                Must be positive and consistent with simulation time units.\n                Smaller time steps provide better accuracy for fast kinetic\n                reactions but increase computational cost.\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            The time step is used for integrating kinetic rate equations.\n            For stiff kinetic systems, smaller time steps may be required\n            for numerical stability and accuracy.\n\n        Examples:\n            &gt;&gt;&gt; dt = 0.1  # 0.1 day time step\n            &gt;&gt;&gt; rm.RM_SetTimeStep(dt)\n            &gt;&gt;&gt; rm.RM_RunCells()  # Integrate kinetics over dt\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetTimeStep(self.id, ctypes.c_double(time_step)))\n\n    def RM_SetUnitsExchange(self, option):\n        \"\"\"Set units for exchange reactions.\n\n        Args:\n            option (int): Units option for exchange calculations.\n\n        Returns:\n            int: IRM_RESULT status code (0 for success).\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetUnitsExchange(self.id, option))\n\n    def RM_SetUnitsGasPhase(self, option) -&gt; None:\n        self.libc.RM_SetUnitsGasPhase(self.id, option)\n\n    def RM_SetUnitsKinetics(self, option) -&gt; None:\n        self.libc.RM_SetUnitsKinetics(self.id, option)\n\n    def RM_SetUnitsPPassemblage(self, option):\n        return self.libc.RM_SetUnitsPPassemblage(self.id, option)\n\n    def RM_SetUnitsSolution(self, option):\n        \"\"\"Set concentration units for aqueous solutions.\n\n        Specifies the units for solution concentrations used in all\n        concentration transfers between the transport model and PhreeqcRM.\n        This affects how concentration data is interpreted and returned.\n\n        Args:\n            option (int): Units option for solution concentrations:\n                1 = mol/L (molar)\n                2 = mmol/L (millimolar) - commonly used\n                3 = \u03bcmol/L (micromolar) - for trace species\n\n        Returns:\n            IRMStatus: Status object with code, name, and message. Use bool(result) to check success.\n\n        Note:\n            This setting affects:\n            - RM_SetConcentrations() input interpretation\n            - RM_GetConcentrations() output units\n            - RM_GetSpeciesConcentrations() output units\n            - Initial condition concentration scaling\n\n        Examples:\n            &gt;&gt;&gt; rm.RM_SetUnitsSolution(2)  # Use mmol/L\n            &gt;&gt;&gt; # Now all concentrations are in millimolar units\n            &gt;&gt;&gt; conc_mmol = np.array([1.0, 0.5, 2.0])  # 1, 0.5, 2 mmol/L\n            &gt;&gt;&gt; rm.RM_SetConcentrations(conc_mmol)\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetUnitsSolution(self.id, option))\n\n    def RM_SetUnitsSSassemblage(self, option):\n        return self.libc.RM_SetUnitsSSassemblage(self.id, option)\n\n    def RM_SetUnitsSurface(self, option):\n        \"\"\"Set units for surface complexation reactions.\n\n        Args:\n            option (int): Units option for surface calculations.\n\n        Returns:\n            int: IRM_RESULT status code (0 for success).\n        \"\"\"\n        return IRM_RESULT(self.libc.RM_SetUnitsSurface(self.id, option))\n\n    def RM_SpeciesConcentrations2Module(self, species_conc):\n        return self.libc.RM_SpeciesConcentrations2Module(self.id, species_conc.ctypes)\n\n    def RM_UseSolutionDensityVolume(self, tf):\n        return self.libc.RM_UseSolutionDensityVolume(self.id, tf)\n\n    def RM_WarningMessage(self, warn_str):\n        return self.libc.RM_WarningMessage(self.id, warn_str)\n\n    def RM_GetComponentCount(self):\n        \"\"\"Get the number of transport components in the system.\n\n        Returns the number of chemical components (elements plus charge balance)\n        that must be transported in reactive transport simulations. This count\n        is determined after calling RM_FindComponents() and defines the size\n        of concentration arrays.\n\n        Returns:\n            int: Number of transport components, which includes:\n                - Chemical elements present in the system (e.g., Ca, Cl, C)\n                - Electric charge balance component\n                - Isotopes if defined in the database\n                - Excludes H2O unless RM_SetComponentH2O(1) was called\n\n        Note:\n            This method should be called after RM_FindComponents() to get the\n            correct component count. The returned value determines array sizes\n            for RM_SetConcentrations() and RM_GetConcentrations().\n\n        Examples:\n            &gt;&gt;&gt; rm.run_initial_from_file(\"initial.pqi\", ic_array)\n            &gt;&gt;&gt; ncomp = rm.RM_GetComponentCount()\n            &gt;&gt;&gt; conc_array = np.zeros(nxyz * ncomp)\n            &gt;&gt;&gt; rm.RM_GetConcentrations(conc_array)\n        \"\"\"\n        return self.libc.RM_GetComponentCount(self.id)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.__init__","title":"<code>__init__()</code>","text":"<p>Initialize PhreeqcRM instance.</p> <p>Creates a new PhreeqcRM object with default values. The instance must be created using the create() method before it can be used for calculations.</p> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize PhreeqcRM instance.\n\n    Creates a new PhreeqcRM object with default values. The instance must be\n    created using the create() method before it can be used for calculations.\n    \"\"\"\n    self._initialized = False\n    self.dllpath = None\n    self.nxyz = 1\n    self.n_threads = 1\n    self.libc = None\n    self.id = None\n    self.components = None\n    self.species = None\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.create","title":"<code>create(dllpath=None, nxyz=1, n_threads=1)</code>","text":"<p>Creates a PhreeqcRM reaction module instance.</p> <p>Initializes the PhreeqcRM library, loads the dynamic library, and creates a reaction module with the specified number of grid cells and threads. This method must be called before any other PhreeqcRM operations.</p> <p>Parameters:</p> Name Type Description Default <code>dllpath</code> <code>str</code> <p>Path to the PhreeqcRM library. If None, uses the default library path based on the operating system. Defaults to None.</p> <code>None</code> <code>nxyz</code> <code>int</code> <p>Number of grid cells in the model. Must be positive. Defaults to 1.</p> <code>1</code> <code>n_threads</code> <code>int</code> <p>Number of threads for parallel processing. Use -1 for automatic detection of CPU count. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the operating system is not supported (Windows/Linux only).</p> <code>RuntimeError</code> <p>If PhreeqcRM instance creation fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm = PhreeqcRM()\n&gt;&gt;&gt; rm.create(nxyz=100, n_threads=4)\n</code></pre> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def create(self, dllpath=None, nxyz=1, n_threads=1) -&gt; None:\n    \"\"\"Creates a PhreeqcRM reaction module instance.\n\n    Initializes the PhreeqcRM library, loads the dynamic library, and creates\n    a reaction module with the specified number of grid cells and threads.\n    This method must be called before any other PhreeqcRM operations.\n\n    Args:\n        dllpath (str, optional): Path to the PhreeqcRM library. If None,\n            uses the default library path based on the operating system.\n            Defaults to None.\n        nxyz (int, optional): Number of grid cells in the model. Must be\n            positive. Defaults to 1.\n        n_threads (int, optional): Number of threads for parallel processing.\n            Use -1 for automatic detection of CPU count. Defaults to 1.\n\n    Raises:\n        Exception: If the operating system is not supported (Windows/Linux only).\n        RuntimeError: If PhreeqcRM instance creation fails.\n\n    Examples:\n        &gt;&gt;&gt; rm = PhreeqcRM()\n        &gt;&gt;&gt; rm.create(nxyz=100, n_threads=4)\n    \"\"\"\n    if dllpath is None:\n        # If no path is provided, use the default path, based on operating system\n        if os.name == \"nt\":\n            dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.dll\")\n        elif os.name == \"posix\":\n            dllpath = os.path.join(os.path.dirname(__file__), \"lib\", \"PhreeqcRM.so\")\n        else:\n            msg = \"Operating system not supported\"\n            raise Exception(msg)\n    self.dllpath = dllpath\n\n    if n_threads == -1:\n        n_threads = os.cpu_count()\n\n    self.n_threads = n_threads\n    self.nxyz = nxyz\n    self.libc = ctypes.CDLL(dllpath)\n    try:\n        self.id = self.libc.RM_Create(nxyz, n_threads)\n        self._initialized = True\n    except Exception as e:\n        msg = f\"Failed to create PhreeqcRM instance: {e}\"\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.get_selected_output_df","title":"<code>get_selected_output_df()</code>","text":"<p>Retrieve selected output data as a pandas DataFrame.</p> <p>Extracts the current selected output data from PhreeqcRM and formats it as a pandas DataFrame with appropriate column headers. Selected output typically includes calculated properties like pH, pe, ionic strength, activities, saturation indices, and user-defined calculations.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas.DataFrame: DataFrame containing selected output data with rows representing grid cells and columns representing the selected output variables defined in the PHREEQC input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = rm.get_selected_output_df()\n&gt;&gt;&gt; print(df.columns)  # Show available output variables\n&gt;&gt;&gt; print(df['pH'])     # Access pH values for all cells\n</code></pre> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def get_selected_output_df(self) -&gt; pd.DataFrame:\n    \"\"\"Retrieve selected output data as a pandas DataFrame.\n\n    Extracts the current selected output data from PhreeqcRM and formats it\n    as a pandas DataFrame with appropriate column headers. Selected output\n    typically includes calculated properties like pH, pe, ionic strength,\n    activities, saturation indices, and user-defined calculations.\n\n    Returns:\n        pandas.DataFrame: DataFrame containing selected output data with\n            rows representing grid cells and columns representing the\n            selected output variables defined in the PHREEQC input.\n\n    Examples:\n        &gt;&gt;&gt; df = rm.get_selected_output_df()\n        &gt;&gt;&gt; print(df.columns)  # Show available output variables\n        &gt;&gt;&gt; print(df['pH'])     # Access pH values for all cells\n    \"\"\"\n    # Get selected ouput headings\n    ncolsel = self.RM_GetSelectedOutputColumnCount()\n    selout_h = np.zeros(ncolsel, dtype=\"U100\")\n    for i in range(ncolsel):\n        self.RM_GetSelectedOutputHeading(i, selout_h, 100)\n    so = np.zeros(ncolsel * self.nxyz).reshape(self.nxyz, ncolsel)\n    self.RM_GetSelectedOutput(so)\n    return pd.DataFrame(so.reshape(ncolsel, self.nxyz).T, columns=selout_h)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.initialize_phreeqc","title":"<code>initialize_phreeqc(database_path, units_solution=2, units=1, porosity=1.0, saturation=1.0, multicomponent=True)</code>","text":"<p>Initialize PhreeqcRM with database and default parameters.</p> <p>Loads a thermodynamic database and sets up the PhreeqcRM instance with standard parameters for geochemical calculations. This is a convenience method that handles common initialization tasks.</p> <p>Parameters:</p> Name Type Description Default <code>database_path</code> <code>str</code> <p>Path to the PHREEQC database file (.dat format). Common databases include phreeqc.dat, Amm.dat, pitzer.dat.</p> required <code>units_solution</code> <code>int</code> <p>Units for solution concentrations. 1 = mol/L, 2 = mmol/L, 3 = \u03bcmol/L. Defaults to 2.</p> <code>2</code> <code>units</code> <code>int</code> <p>Units for other phases (Exchange, Surface, Gas, Solid solutions, Kinetics). Defaults to 1.</p> <code>1</code> <code>porosity</code> <code>float</code> <p>Porosity value assigned to all cells. Must be between 0 and 1. Defaults to 1.0.</p> <code>1.0</code> <code>saturation</code> <code>float</code> <p>Saturation value assigned to all cells. Must be between 0 and 1. Defaults to 1.0.</p> <code>1.0</code> <code>multicomponent</code> <code>bool</code> <p>Enable multicomponent diffusion by saving species concentrations. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the PhreeqcRM instance is not initialized or if the database fails to load.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm = PhreeqcRM()\n&gt;&gt;&gt; rm.create(nxyz=100)\n&gt;&gt;&gt; rm.initialize_phreeqc(\"phreeqc.dat\", units_solution=1)\n</code></pre> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def initialize_phreeqc(\n    self,\n    database_path,\n    units_solution=2,\n    units=1,\n    porosity=1.0,\n    saturation=1.0,\n    multicomponent=True,\n) -&gt; None:\n    \"\"\"Initialize PhreeqcRM with database and default parameters.\n\n    Loads a thermodynamic database and sets up the PhreeqcRM instance with\n    standard parameters for geochemical calculations. This is a convenience\n    method that handles common initialization tasks.\n\n    Args:\n        database_path (str): Path to the PHREEQC database file (.dat format).\n            Common databases include phreeqc.dat, Amm.dat, pitzer.dat.\n        units_solution (int, optional): Units for solution concentrations.\n            1 = mol/L, 2 = mmol/L, 3 = \u03bcmol/L. Defaults to 2.\n        units (int, optional): Units for other phases (Exchange, Surface,\n            Gas, Solid solutions, Kinetics). Defaults to 1.\n        porosity (float, optional): Porosity value assigned to all cells.\n            Must be between 0 and 1. Defaults to 1.0.\n        saturation (float, optional): Saturation value assigned to all cells.\n            Must be between 0 and 1. Defaults to 1.0.\n        multicomponent (bool, optional): Enable multicomponent diffusion\n            by saving species concentrations. Defaults to True.\n\n    Raises:\n        RuntimeError: If the PhreeqcRM instance is not initialized or if\n            the database fails to load.\n\n    Examples:\n        &gt;&gt;&gt; rm = PhreeqcRM()\n        &gt;&gt;&gt; rm.create(nxyz=100)\n        &gt;&gt;&gt; rm.initialize_phreeqc(\"phreeqc.dat\", units_solution=1)\n    \"\"\"\n\n    if not self._initialized:\n        raise RuntimeError(\"PhreeqcRM instance not initialized. Call create() first.\")\n\n    # Load database\n    status = self.RM_LoadDatabase(database_path)\n    if not status:\n        raise RuntimeError(f\"Failed to load Phreeqc database: {status}\")\n\n    # Set properties/parameters\n    self.RM_SetComponentH2O(0)  # Don't include H2O in component list\n    self.RM_SetRebalanceFraction(0.5)  # Rebalance thread load\n\n    # Set units\n    self.RM_SetUnitsSolution(units_solution)\n    self.RM_SetUnitsPPassemblage(units)\n    self.RM_SetUnitsExchange(units)\n    self.RM_SetUnitsSurface(units)\n    self.RM_SetUnitsGasPhase(units)\n    self.RM_SetUnitsSSassemblage(units)\n    self.RM_SetUnitsKinetics(units)\n\n    # Set porosity and saturation\n    self.RM_SetPorosity(porosity * np.ones(self.nxyz))\n    self.RM_SetSaturation(saturation * np.ones(self.nxyz))\n\n    # Create error log files\n    self.RM_SetFilePrefix(\"phr\")\n    self.RM_OpenFiles()\n\n    # Multicomponent diffusion settings\n    if multicomponent:\n        self.RM_SetSpeciesSaveOn(1)\n</code></pre>"},{"location":"reference/#mibiremo.phreeqc.PhreeqcRM.run_initial_from_file","title":"<code>run_initial_from_file(pqi_file, ic)</code>","text":"<p>Set up initial conditions from PHREEQC input file and initial conditions array.</p> <p>Loads initial geochemical conditions by running a PHREEQC input file and mapping the defined solutions, phases, and other components to the grid cells. This method also retrieves component and species information for later use.</p> <p>Parameters:</p> Name Type Description Default <code>pqi_file</code> <code>str</code> <p>Path to the PHREEQC input file (.pqi format) containing definitions for solutions, equilibrium phases, exchange, surface, gas phases, solid solutions, and kinetic reactions.</p> required <code>ic</code> <code>ndarray</code> <p>Initial conditions array with shape (nxyz, 7) where each row corresponds to a grid cell and columns represent: - Column 0: Solution ID - Column 1: Equilibrium phase ID - Column 2: Exchange ID - Column 3: Surface ID - Column 4: Gas phase ID - Column 5: Solid solution ID - Column 6: Kinetic reaction ID Use -1 for unused components.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the PHREEQC input file fails to run.</p> <code>ValueError</code> <p>If initial conditions array has incorrect shape or cannot be converted to integer array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; ic = np.array([[1, -1, -1, -1, -1, -1, -1]])  # Only solution 1\n&gt;&gt;&gt; rm.run_initial_from_file(\"initial.pqi\", ic)\n</code></pre> Source code in <code>mibiremo/phreeqc.py</code> <pre><code>def run_initial_from_file(self, pqi_file, ic):\n    \"\"\"Set up initial conditions from PHREEQC input file and initial conditions array.\n\n    Loads initial geochemical conditions by running a PHREEQC input file and\n    mapping the defined solutions, phases, and other components to the grid cells.\n    This method also retrieves component and species information for later use.\n\n    Args:\n        pqi_file (str): Path to the PHREEQC input file (.pqi format) containing\n            definitions for solutions, equilibrium phases, exchange, surface,\n            gas phases, solid solutions, and kinetic reactions.\n        ic (numpy.ndarray): Initial conditions array with shape (nxyz, 7) where\n            each row corresponds to a grid cell and columns represent:\n            - Column 0: Solution ID\n            - Column 1: Equilibrium phase ID\n            - Column 2: Exchange ID\n            - Column 3: Surface ID\n            - Column 4: Gas phase ID\n            - Column 5: Solid solution ID\n            - Column 6: Kinetic reaction ID\n            Use -1 for unused components.\n\n    Raises:\n        RuntimeError: If the PHREEQC input file fails to run.\n        ValueError: If initial conditions array has incorrect shape or cannot\n            be converted to integer array.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; ic = np.array([[1, -1, -1, -1, -1, -1, -1]])  # Only solution 1\n        &gt;&gt;&gt; rm.run_initial_from_file(\"initial.pqi\", ic)\n    \"\"\"\n\n    # Run the initial setup file\n    status = self.RM_RunFile(1, 1, 1, pqi_file)\n    if not status:\n        raise RuntimeError(f\"Failed to run Phreeqc input file: {status}\")\n\n    # Check size of initial conditions array\n    if ic.shape != (self.nxyz, 7):\n        raise ValueError(f\"Initial conditions array must have shape ({self.nxyz}, 7), got {ic.shape}\")\n\n    # Be sure that ic is a numpy array\n    if not isinstance(ic, np.ndarray):\n        try:\n            ic = np.array(ic).astype(np.int32)\n        except Exception as e:\n            raise ValueError(\"Initial conditions must be convertible to a numpy array of integers\") from e\n\n    # Reshape initial conditions to 1D array\n    ic1 = np.reshape(ic.T, self.nxyz * 7).astype(np.int32)\n\n    # ic2 contains numbers for a second entity that mixes with the first entity (here, it is not used)\n    ic2 = -1 * np.ones(self.nxyz * 7, dtype=np.int32)\n\n    # f1 contains the fractions of the first entity in each cell (here, it is set to 1.0)\n    f1 = np.ones(self.nxyz * 7, dtype=np.float64)\n\n    status = self.RM_InitialPhreeqc2Module(ic1, ic2, f1)\n\n    # Get component and species information\n    n_comps = self.RM_FindComponents()\n    n_species = self.RM_GetSpeciesCount()\n\n    self.components = np.zeros(n_comps, dtype=\"U20\")\n    for i in range(n_comps):\n        self.RM_GetComponent(i, self.components, 20)\n\n    self.species = np.zeros(n_species, dtype=\"U20\")\n    for i in range(n_species):\n        self.RM_GetSpeciesName(i, self.species, 20)\n\n    # Run initial equilibrium step\n    self.RM_SetTime(0.0)\n    self.RM_SetTimeStep(0.0)\n    status = self.RM_RunCells()\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver","title":"<code>semilagsolver</code>","text":"<p>Semi-Lagrangian solver for 1D advection-diffusion equation on a uniform grid.</p> <p>Author: Matteo Masi Last revision: 09/09/2024</p>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver","title":"<code>SemiLagSolver</code>","text":"<p>Semi-Lagrangian solver for 1D advection-diffusion transport equations.</p> <p>This class implements a semi-Lagrangian numerical scheme for solving the one-dimensional advection-diffusion equation on uniform grids. The solver uses operator splitting to handle advection and diffusion separately, providing accurate and stable solutions for transport problems.</p> The numerical approach consists of two sequential steps <ol> <li>Advection: Solved using the Method of Characteristics (MOC) with    cubic spline interpolation (PCHIP - Piecewise Cubic Hermite Interpolating    Polynomial) to maintain monotonicity and prevent oscillations.</li> <li>Diffusion: Solved using the Saul\u2019yev alternating direction method,    which provides unconditional stability for the diffusion equation.</li> </ol> Boundary Conditions <ul> <li>Inlet (left boundary, x=0): Dirichlet-type condition with prescribed   concentration value.</li> <li>Outlet (right boundary): Neumann-type condition (zero gradient) allowing   natural outflow of transported species.</li> </ul> Mathematical Formulation <p>The solver addresses the 1D advection-diffusion equation:</p> <p>\u2202C/\u2202t + v\u2202C/\u2202x = D\u2202\u00b2C/\u2202x\u00b2</p> <p>where: - C(x,t): Concentration field - v: Advection velocity (constant) - D: Diffusion/dispersion coefficient (constant)</p> Numerical Stability <ul> <li>The cubic spline advection step is stable for any Courant number</li> <li>The Saul\u2019yev diffusion solver is unconditionally stable</li> <li>Combined scheme maintains stability and accuracy for typical transport problems</li> </ul> Applications <ul> <li>Reactive transport modeling in porous media</li> <li>Contaminant transport in groundwater systems</li> <li>Chemical species transport in environmental flows</li> <li>Coupling with geochemical reaction modules (e.g., PhreeqcRM)</li> </ul> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>Spatial coordinate array (uniform spacing required).</p> <code>C</code> <code>ndarray</code> <p>Current concentration field at grid points.</p> <code>v</code> <code>float</code> <p>Advection velocity in consistent units with spatial coordinates.</p> <code>D</code> <code>float</code> <p>Diffusion coefficient in consistent units (L\u00b2/T).</p> <code>dt</code> <code>float</code> <p>Time step for numerical integration in consistent time units.</p> <code>dx</code> <code>float</code> <p>Spatial grid spacing (automatically calculated from x).</p> Note <p>The spatial grid must be uniformly spaced for the numerical scheme to work correctly. Non-uniform grids are not supported in this implementation.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>class SemiLagSolver:\n    \"\"\"Semi-Lagrangian solver for 1D advection-diffusion transport equations.\n\n    This class implements a semi-Lagrangian numerical scheme for solving the\n    one-dimensional advection-diffusion equation on uniform grids. The solver\n    uses operator splitting to handle advection and diffusion separately,\n    providing accurate and stable solutions for transport problems.\n\n    The numerical approach consists of two sequential steps:\n        1. **Advection**: Solved using the Method of Characteristics (MOC) with\n           cubic spline interpolation (PCHIP - Piecewise Cubic Hermite Interpolating\n           Polynomial) to maintain monotonicity and prevent oscillations.\n        2. **Diffusion**: Solved using the Saul'yev alternating direction method,\n           which provides unconditional stability for the diffusion equation.\n\n    Boundary Conditions:\n        - **Inlet (left boundary, x=0)**: Dirichlet-type condition with prescribed\n          concentration value.\n        - **Outlet (right boundary)**: Neumann-type condition (zero gradient) allowing\n          natural outflow of transported species.\n\n    Mathematical Formulation:\n        The solver addresses the 1D advection-diffusion equation:\n\n        \u2202C/\u2202t + v\u2202C/\u2202x = D\u2202\u00b2C/\u2202x\u00b2\n\n        where:\n        - C(x,t): Concentration field\n        - v: Advection velocity (constant)\n        - D: Diffusion/dispersion coefficient (constant)\n\n    Numerical Stability:\n        - The cubic spline advection step is stable for any Courant number\n        - The Saul'yev diffusion solver is unconditionally stable\n        - Combined scheme maintains stability and accuracy for typical transport problems\n\n    Applications:\n        - Reactive transport modeling in porous media\n        - Contaminant transport in groundwater systems\n        - Chemical species transport in environmental flows\n        - Coupling with geochemical reaction modules (e.g., PhreeqcRM)\n\n    Attributes:\n        x (numpy.ndarray): Spatial coordinate array (uniform spacing required).\n        C (numpy.ndarray): Current concentration field at grid points.\n        v (float): Advection velocity in consistent units with spatial coordinates.\n        D (float): Diffusion coefficient in consistent units (L\u00b2/T).\n        dt (float): Time step for numerical integration in consistent time units.\n        dx (float): Spatial grid spacing (automatically calculated from x).\n\n    Note:\n        The spatial grid must be uniformly spaced for the numerical scheme to\n        work correctly. Non-uniform grids are not supported in this implementation.\n    \"\"\"\n\n    def __init__(self, x, C_init, v, D, dt):\n        \"\"\"Initialize the Semi-Lagrangian solver with transport parameters.\n\n        Sets up the numerical solver with spatial discretization, initial conditions,\n        and transport parameters. Validates input consistency and calculates derived\n        parameters needed for the numerical scheme.\n\n        Args:\n            x (numpy.ndarray): Spatial coordinate array defining the 1D computational\n                domain. Must be uniformly spaced with at least 2 points. Units should\n                be consistent with velocity and diffusion coefficient.\n            C_init (numpy.ndarray): Initial concentration field at each grid point.\n                Length must match the spatial coordinate array. Units are user-defined\n                but should be consistent throughout the simulation.\n            v (float): Advection velocity (positive for left-to-right flow).\n                Units must be consistent with spatial coordinates and time step\n                (e.g., if x is in meters and dt in days, v should be in m/day).\n            D (float): Diffusion/dispersion coefficient (must be non-negative).\n                Units must be L\u00b2/T where L and T are consistent with spatial\n                coordinates and time step (e.g., m\u00b2/day).\n            dt (float): Time step for numerical integration (must be positive).\n                Units should be consistent with velocity and diffusion coefficient.\n\n        Raises:\n            ValueError: If spatial coordinates are not uniformly spaced or if\n                concentration array length doesn't match spatial coordinates.\n            ValueError: If transport parameters are not physically reasonable\n                (negative diffusion, zero or negative time step).\n\n        Examples:\n            &gt;&gt;&gt; x = np.linspace(0, 5, 51)      # 5 m domain, 0.1 m spacing\n            &gt;&gt;&gt; C0 = np.exp(-x**2)             # Gaussian initial condition\n            &gt;&gt;&gt; solver = SemiLagSolver(x, C0, v=0.5, D=0.05, dt=0.01)\n        \"\"\"\n        if len(x) != len(C_init):\n            raise ValueError(f\"Length of x ({len(x)}) must match length of C_init ({len(C_init)})\")\n\n        if len(x) &lt; 2:\n            raise ValueError(f\"Grid must have at least 2 points, got {len(x)}\")\n\n        self.x = x\n        self.C = C_init\n        self.v = v\n        self.D = D\n        self.dt = dt\n        self.dx = x[1] - x[0]\n\n    def cubic_spline_advection(self, C_bound) -&gt; None:\n        \"\"\"Solve the advection step using cubic spline interpolation.\n\n        Implements the Method of Characteristics (MOC) for the advection equation\n        \u2202C/\u2202t + v\u2202C/\u2202x = 0 using backward tracking of characteristic lines.\n        Uses PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) to maintain\n        monotonicity and prevent numerical oscillations.\n\n        The method works by:\n            1. Computing departure points: xi = x - v*dt (backward tracking)\n            2. Interpolating concentrations at departure points using cubic splines\n            3. Applying inlet boundary condition for points that tracked outside domain\n\n        Args:\n            C_bound (float): Inlet concentration value applied at the left boundary\n                (x=0) for any characteristic lines that originated from outside the\n                computational domain. Units should match the concentration field.\n\n        Note:\n            This method modifies self.C in-place. The cubic spline interpolation\n            preserves monotonicity, making it suitable for concentration fields\n            where spurious oscillations must be avoided.\n\n        Numerical Properties:\n            - Unconditionally stable (no CFL restriction)\n            - Maintains monotonicity (no new extrema created)\n            - Handles arbitrary Courant numbers (v*dt/dx)\n            - Exact for linear concentration profiles\n        \"\"\"\n        cs = PchipInterpolator(self.x, self.C)\n        shift = self.v * self.dt\n        xi = self.x - shift\n        k0 = xi &lt;= 0\n        xi[k0] = 0\n        yi = cs(xi)\n        yi[k0] = C_bound\n        self.C = yi\n\n    def saulyev_solver_alt(self, C_bound) -&gt; None:\n        \"\"\"Solve the diffusion step using the Saul'yev alternating direction method.\n\n        Implements the Saul'yev scheme for the diffusion equation \u2202C/\u2202t = D\u2202\u00b2C/\u2202x\u00b2\n        using alternating direction sweeps to achieve unconditional stability.\n        The method performs two passes:\n            1. Left-to-right sweep using forward differences\n            2. Right-to-left sweep using backward differences\n            3. Final solution is the average of both sweeps\n\n        Args:\n            C_bound (float): Inlet concentration value applied at the left boundary\n                during the diffusion solve. This maintains consistency with the\n                advection boundary condition.\n\n        Algorithm Details:\n            - **Left-to-Right Pass**: For each cell i, uses implicit treatment of\n              left neighbor and explicit treatment of right neighbor\n            - **Right-to-Left Pass**: For each cell i, uses implicit treatment of\n              right neighbor and explicit treatment of left neighbor\n            - **Averaging**: Combines both solutions to achieve second-order accuracy\n\n        Boundary Conditions:\n            - **Left boundary (x=0)**: Dirichlet condition with prescribed C_bound\n            - **Right boundary**: Zero gradient (Neumann) condition implemented\n              by using the same concentration as the last interior point\n\n        Numerical Properties:\n            - Unconditionally stable for any time step size\n            - Second-order accurate in space and time\n            - Preserves maximum principle (no spurious extrema)\n            - Handles arbitrary diffusion numbers (D*dt/dx\u00b2)\n\n        Note:\n            This method modifies self.C in-place. The alternating direction\n            approach eliminates the restrictive stability constraint of explicit\n            methods while maintaining computational efficiency.\n        \"\"\"\n        dt = self.dt\n        theta = self.D * dt / (self.dx**2)\n\n        # Assign current C state as initial condition\n        C_init = self.C.copy()\n        CLR = self.C.copy()\n        CRL = self.C.copy()\n\n        # A) L-R direction\n        for i in range(len(CLR)):\n            if i == 0:  # left boundary\n                solA = theta * C_bound\n            else:\n                solA = theta * CLR[i - 1]\n            solB = (1 - theta) * C_init[i]\n            solC = theta * C_init[i + 1] if i &lt; len(CLR) - 1 else theta * C_init[i]\n            # L-R Solution\n            CLR[i] = (solA + solB + solC) / (1 + theta)\n\n        # B) R-L direction\n        for i in range(len(CRL) - 1, -1, -1):\n            if i == len(CRL) - 1:  # right boundary (take from LR solution)\n                solA = theta * CLR[-1]\n            else:\n                solA = theta * CRL[i + 1]\n            solB = (1 - theta) * C_init[i]\n            solC = theta * C_init[i - 1] if i &gt; 0 else theta * C_init[i]\n            # R-L Solution\n            CRL[i] = (solA + solB + solC) / (1 + theta)\n\n        # Average L-R and R-L solutions and update to final state\n        self.C = (CLR + CRL) / 2\n\n    def transport(self, C_bound) -&gt; np.ndarray:\n        \"\"\"Perform one complete transport time step with coupled advection-diffusion.\n\n        Executes the full semi-Lagrangian algorithm by sequentially applying\n        the advection and diffusion operators using operator splitting. This\n        approach decouples the hyperbolic (advection) and parabolic (diffusion)\n        aspects of the transport equation for enhanced numerical stability.\n\n        The operator splitting sequence:\n            1. **Advection Step** using cubic spline MOC\n            2. **Diffusion Step** using Saul'yev method\n\n        Args:\n            C_bound (float): Inlet boundary concentration applied at x=0 for both\n                advection and diffusion steps. This represents the concentration\n                of material entering the domain (e.g., injection well concentration,\n                upstream boundary condition, etc.).\n\n        Returns:\n            numpy.ndarray: Updated concentration field after the complete transport\n                step. The array has the same shape as the initial concentration\n                and represents C(x, t+dt).\n\n        Note:\n            This method updates the internal concentration field (self.C) and\n            returns the updated values. For reactive transport coupling, call\n            this method to advance transport, then apply geochemical reactions\n            to the returned concentration field.\n        \"\"\"\n        # Step 1: Solve advection equation using cubic spline MOC\n        self.cubic_spline_advection(C_bound)\n\n        # Step 2: Solve diffusion equation using Saul'yev alternating direction method\n        self.saulyev_solver_alt(C_bound)\n\n        return self.C\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.__init__","title":"<code>__init__(x, C_init, v, D, dt)</code>","text":"<p>Initialize the Semi-Lagrangian solver with transport parameters.</p> <p>Sets up the numerical solver with spatial discretization, initial conditions, and transport parameters. Validates input consistency and calculates derived parameters needed for the numerical scheme.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Spatial coordinate array defining the 1D computational domain. Must be uniformly spaced with at least 2 points. Units should be consistent with velocity and diffusion coefficient.</p> required <code>C_init</code> <code>ndarray</code> <p>Initial concentration field at each grid point. Length must match the spatial coordinate array. Units are user-defined but should be consistent throughout the simulation.</p> required <code>v</code> <code>float</code> <p>Advection velocity (positive for left-to-right flow). Units must be consistent with spatial coordinates and time step (e.g., if x is in meters and dt in days, v should be in m/day).</p> required <code>D</code> <code>float</code> <p>Diffusion/dispersion coefficient (must be non-negative). Units must be L\u00b2/T where L and T are consistent with spatial coordinates and time step (e.g., m\u00b2/day).</p> required <code>dt</code> <code>float</code> <p>Time step for numerical integration (must be positive). Units should be consistent with velocity and diffusion coefficient.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If spatial coordinates are not uniformly spaced or if concentration array length doesn\u2019t match spatial coordinates.</p> <code>ValueError</code> <p>If transport parameters are not physically reasonable (negative diffusion, zero or negative time step).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = np.linspace(0, 5, 51)      # 5 m domain, 0.1 m spacing\n&gt;&gt;&gt; C0 = np.exp(-x**2)             # Gaussian initial condition\n&gt;&gt;&gt; solver = SemiLagSolver(x, C0, v=0.5, D=0.05, dt=0.01)\n</code></pre> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def __init__(self, x, C_init, v, D, dt):\n    \"\"\"Initialize the Semi-Lagrangian solver with transport parameters.\n\n    Sets up the numerical solver with spatial discretization, initial conditions,\n    and transport parameters. Validates input consistency and calculates derived\n    parameters needed for the numerical scheme.\n\n    Args:\n        x (numpy.ndarray): Spatial coordinate array defining the 1D computational\n            domain. Must be uniformly spaced with at least 2 points. Units should\n            be consistent with velocity and diffusion coefficient.\n        C_init (numpy.ndarray): Initial concentration field at each grid point.\n            Length must match the spatial coordinate array. Units are user-defined\n            but should be consistent throughout the simulation.\n        v (float): Advection velocity (positive for left-to-right flow).\n            Units must be consistent with spatial coordinates and time step\n            (e.g., if x is in meters and dt in days, v should be in m/day).\n        D (float): Diffusion/dispersion coefficient (must be non-negative).\n            Units must be L\u00b2/T where L and T are consistent with spatial\n            coordinates and time step (e.g., m\u00b2/day).\n        dt (float): Time step for numerical integration (must be positive).\n            Units should be consistent with velocity and diffusion coefficient.\n\n    Raises:\n        ValueError: If spatial coordinates are not uniformly spaced or if\n            concentration array length doesn't match spatial coordinates.\n        ValueError: If transport parameters are not physically reasonable\n            (negative diffusion, zero or negative time step).\n\n    Examples:\n        &gt;&gt;&gt; x = np.linspace(0, 5, 51)      # 5 m domain, 0.1 m spacing\n        &gt;&gt;&gt; C0 = np.exp(-x**2)             # Gaussian initial condition\n        &gt;&gt;&gt; solver = SemiLagSolver(x, C0, v=0.5, D=0.05, dt=0.01)\n    \"\"\"\n    if len(x) != len(C_init):\n        raise ValueError(f\"Length of x ({len(x)}) must match length of C_init ({len(C_init)})\")\n\n    if len(x) &lt; 2:\n        raise ValueError(f\"Grid must have at least 2 points, got {len(x)}\")\n\n    self.x = x\n    self.C = C_init\n    self.v = v\n    self.D = D\n    self.dt = dt\n    self.dx = x[1] - x[0]\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.cubic_spline_advection","title":"<code>cubic_spline_advection(C_bound)</code>","text":"<p>Solve the advection step using cubic spline interpolation.</p> <p>Implements the Method of Characteristics (MOC) for the advection equation \u2202C/\u2202t + v\u2202C/\u2202x = 0 using backward tracking of characteristic lines. Uses PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) to maintain monotonicity and prevent numerical oscillations.</p> The method works by <ol> <li>Computing departure points: xi = x - v*dt (backward tracking)</li> <li>Interpolating concentrations at departure points using cubic splines</li> <li>Applying inlet boundary condition for points that tracked outside domain</li> </ol> <p>Parameters:</p> Name Type Description Default <code>C_bound</code> <code>float</code> <p>Inlet concentration value applied at the left boundary (x=0) for any characteristic lines that originated from outside the computational domain. Units should match the concentration field.</p> required Note <p>This method modifies self.C in-place. The cubic spline interpolation preserves monotonicity, making it suitable for concentration fields where spurious oscillations must be avoided.</p> Numerical Properties <ul> <li>Unconditionally stable (no CFL restriction)</li> <li>Maintains monotonicity (no new extrema created)</li> <li>Handles arbitrary Courant numbers (v*dt/dx)</li> <li>Exact for linear concentration profiles</li> </ul> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def cubic_spline_advection(self, C_bound) -&gt; None:\n    \"\"\"Solve the advection step using cubic spline interpolation.\n\n    Implements the Method of Characteristics (MOC) for the advection equation\n    \u2202C/\u2202t + v\u2202C/\u2202x = 0 using backward tracking of characteristic lines.\n    Uses PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) to maintain\n    monotonicity and prevent numerical oscillations.\n\n    The method works by:\n        1. Computing departure points: xi = x - v*dt (backward tracking)\n        2. Interpolating concentrations at departure points using cubic splines\n        3. Applying inlet boundary condition for points that tracked outside domain\n\n    Args:\n        C_bound (float): Inlet concentration value applied at the left boundary\n            (x=0) for any characteristic lines that originated from outside the\n            computational domain. Units should match the concentration field.\n\n    Note:\n        This method modifies self.C in-place. The cubic spline interpolation\n        preserves monotonicity, making it suitable for concentration fields\n        where spurious oscillations must be avoided.\n\n    Numerical Properties:\n        - Unconditionally stable (no CFL restriction)\n        - Maintains monotonicity (no new extrema created)\n        - Handles arbitrary Courant numbers (v*dt/dx)\n        - Exact for linear concentration profiles\n    \"\"\"\n    cs = PchipInterpolator(self.x, self.C)\n    shift = self.v * self.dt\n    xi = self.x - shift\n    k0 = xi &lt;= 0\n    xi[k0] = 0\n    yi = cs(xi)\n    yi[k0] = C_bound\n    self.C = yi\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.saulyev_solver_alt","title":"<code>saulyev_solver_alt(C_bound)</code>","text":"<p>Solve the diffusion step using the Saul\u2019yev alternating direction method.</p> <p>Implements the Saul\u2019yev scheme for the diffusion equation \u2202C/\u2202t = D\u2202\u00b2C/\u2202x\u00b2 using alternating direction sweeps to achieve unconditional stability. The method performs two passes:     1. Left-to-right sweep using forward differences     2. Right-to-left sweep using backward differences     3. Final solution is the average of both sweeps</p> <p>Parameters:</p> Name Type Description Default <code>C_bound</code> <code>float</code> <p>Inlet concentration value applied at the left boundary during the diffusion solve. This maintains consistency with the advection boundary condition.</p> required Algorithm Details <ul> <li>Left-to-Right Pass: For each cell i, uses implicit treatment of   left neighbor and explicit treatment of right neighbor</li> <li>Right-to-Left Pass: For each cell i, uses implicit treatment of   right neighbor and explicit treatment of left neighbor</li> <li>Averaging: Combines both solutions to achieve second-order accuracy</li> </ul> Boundary Conditions <ul> <li>Left boundary (x=0): Dirichlet condition with prescribed C_bound</li> <li>Right boundary: Zero gradient (Neumann) condition implemented   by using the same concentration as the last interior point</li> </ul> Numerical Properties <ul> <li>Unconditionally stable for any time step size</li> <li>Second-order accurate in space and time</li> <li>Preserves maximum principle (no spurious extrema)</li> <li>Handles arbitrary diffusion numbers (D*dt/dx\u00b2)</li> </ul> Note <p>This method modifies self.C in-place. The alternating direction approach eliminates the restrictive stability constraint of explicit methods while maintaining computational efficiency.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def saulyev_solver_alt(self, C_bound) -&gt; None:\n    \"\"\"Solve the diffusion step using the Saul'yev alternating direction method.\n\n    Implements the Saul'yev scheme for the diffusion equation \u2202C/\u2202t = D\u2202\u00b2C/\u2202x\u00b2\n    using alternating direction sweeps to achieve unconditional stability.\n    The method performs two passes:\n        1. Left-to-right sweep using forward differences\n        2. Right-to-left sweep using backward differences\n        3. Final solution is the average of both sweeps\n\n    Args:\n        C_bound (float): Inlet concentration value applied at the left boundary\n            during the diffusion solve. This maintains consistency with the\n            advection boundary condition.\n\n    Algorithm Details:\n        - **Left-to-Right Pass**: For each cell i, uses implicit treatment of\n          left neighbor and explicit treatment of right neighbor\n        - **Right-to-Left Pass**: For each cell i, uses implicit treatment of\n          right neighbor and explicit treatment of left neighbor\n        - **Averaging**: Combines both solutions to achieve second-order accuracy\n\n    Boundary Conditions:\n        - **Left boundary (x=0)**: Dirichlet condition with prescribed C_bound\n        - **Right boundary**: Zero gradient (Neumann) condition implemented\n          by using the same concentration as the last interior point\n\n    Numerical Properties:\n        - Unconditionally stable for any time step size\n        - Second-order accurate in space and time\n        - Preserves maximum principle (no spurious extrema)\n        - Handles arbitrary diffusion numbers (D*dt/dx\u00b2)\n\n    Note:\n        This method modifies self.C in-place. The alternating direction\n        approach eliminates the restrictive stability constraint of explicit\n        methods while maintaining computational efficiency.\n    \"\"\"\n    dt = self.dt\n    theta = self.D * dt / (self.dx**2)\n\n    # Assign current C state as initial condition\n    C_init = self.C.copy()\n    CLR = self.C.copy()\n    CRL = self.C.copy()\n\n    # A) L-R direction\n    for i in range(len(CLR)):\n        if i == 0:  # left boundary\n            solA = theta * C_bound\n        else:\n            solA = theta * CLR[i - 1]\n        solB = (1 - theta) * C_init[i]\n        solC = theta * C_init[i + 1] if i &lt; len(CLR) - 1 else theta * C_init[i]\n        # L-R Solution\n        CLR[i] = (solA + solB + solC) / (1 + theta)\n\n    # B) R-L direction\n    for i in range(len(CRL) - 1, -1, -1):\n        if i == len(CRL) - 1:  # right boundary (take from LR solution)\n            solA = theta * CLR[-1]\n        else:\n            solA = theta * CRL[i + 1]\n        solB = (1 - theta) * C_init[i]\n        solC = theta * C_init[i - 1] if i &gt; 0 else theta * C_init[i]\n        # R-L Solution\n        CRL[i] = (solA + solB + solC) / (1 + theta)\n\n    # Average L-R and R-L solutions and update to final state\n    self.C = (CLR + CRL) / 2\n</code></pre>"},{"location":"reference/#mibiremo.semilagsolver.SemiLagSolver.transport","title":"<code>transport(C_bound)</code>","text":"<p>Perform one complete transport time step with coupled advection-diffusion.</p> <p>Executes the full semi-Lagrangian algorithm by sequentially applying the advection and diffusion operators using operator splitting. This approach decouples the hyperbolic (advection) and parabolic (diffusion) aspects of the transport equation for enhanced numerical stability.</p> The operator splitting sequence <ol> <li>Advection Step using cubic spline MOC</li> <li>Diffusion Step using Saul\u2019yev method</li> </ol> <p>Parameters:</p> Name Type Description Default <code>C_bound</code> <code>float</code> <p>Inlet boundary concentration applied at x=0 for both advection and diffusion steps. This represents the concentration of material entering the domain (e.g., injection well concentration, upstream boundary condition, etc.).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Updated concentration field after the complete transport step. The array has the same shape as the initial concentration and represents C(x, t+dt).</p> Note <p>This method updates the internal concentration field (self.C) and returns the updated values. For reactive transport coupling, call this method to advance transport, then apply geochemical reactions to the returned concentration field.</p> Source code in <code>mibiremo/semilagsolver.py</code> <pre><code>def transport(self, C_bound) -&gt; np.ndarray:\n    \"\"\"Perform one complete transport time step with coupled advection-diffusion.\n\n    Executes the full semi-Lagrangian algorithm by sequentially applying\n    the advection and diffusion operators using operator splitting. This\n    approach decouples the hyperbolic (advection) and parabolic (diffusion)\n    aspects of the transport equation for enhanced numerical stability.\n\n    The operator splitting sequence:\n        1. **Advection Step** using cubic spline MOC\n        2. **Diffusion Step** using Saul'yev method\n\n    Args:\n        C_bound (float): Inlet boundary concentration applied at x=0 for both\n            advection and diffusion steps. This represents the concentration\n            of material entering the domain (e.g., injection well concentration,\n            upstream boundary condition, etc.).\n\n    Returns:\n        numpy.ndarray: Updated concentration field after the complete transport\n            step. The array has the same shape as the initial concentration\n            and represents C(x, t+dt).\n\n    Note:\n        This method updates the internal concentration field (self.C) and\n        returns the updated values. For reactive transport coupling, call\n        this method to advance transport, then apply geochemical reactions\n        to the returned concentration field.\n    \"\"\"\n    # Step 1: Solve advection equation using cubic spline MOC\n    self.cubic_spline_advection(C_bound)\n\n    # Step 2: Solve diffusion equation using Saul'yev alternating direction method\n    self.saulyev_solver_alt(C_bound)\n\n    return self.C\n</code></pre>"}]}